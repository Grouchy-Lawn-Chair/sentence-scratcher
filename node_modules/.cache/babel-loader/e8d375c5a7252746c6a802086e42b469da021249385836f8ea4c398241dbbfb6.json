{"ast":null,"code":"import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\nconst olDOM = [\"ol\", 0],\n  ulDOM = [\"ul\", 0],\n  liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n  attrs: {\n    order: {\n      default: 1,\n      validate: \"number\"\n    }\n  },\n  parseDOM: [{\n    tag: \"ol\",\n    getAttrs(dom) {\n      return {\n        order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n      };\n    }\n  }],\n  toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {\n      start: node.attrs.order\n    }, 0];\n  }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n  parseDOM: [{\n    tag: \"ul\"\n  }],\n  toDOM() {\n    return ulDOM;\n  }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n  parseDOM: [{\n    tag: \"li\"\n  }],\n  toDOM() {\n    return liDOM;\n  },\n  defining: true\n};\nfunction add(obj, props) {\n  let copy = {};\n  for (let prop in obj) copy[prop] = obj[prop];\n  for (let prop in props) copy[prop] = props[prop];\n  return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    bullet_list: add(bulletList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    list_item: add(listItem, {\n      content: itemContent\n    })\n  });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to);\n    if (!range) return false;\n    let tr = dispatch ? state.tr : null;\n    if (!wrapRangeInList(tr, range, listType, attrs)) return false;\n    if (dispatch) dispatch(tr.scrollIntoView());\n    return true;\n  };\n}\n/**\nTry to wrap the given node range in a list of the given type.\nReturn `true` when this is possible, `false` otherwise. When `tr`\nis non-null, the wrapping is added to that transaction. When it is\n`null`, the function only queries whether the wrapping is\npossible.\n*/\nfunction wrapRangeInList(tr, range, listType) {\n  let attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let doJoin = false,\n    outerRange = range,\n    doc = range.$from.doc;\n  // This is at the top of an existing list item\n  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n    // Don't do anything if this is the top of the list\n    if (range.$from.index(range.depth - 1) == 0) return false;\n    let $insert = doc.resolve(range.start - 2);\n    outerRange = new NodeRange($insert, $insert, range.depth);\n    if (range.endIndex < range.parent.childCount) range = new NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n    doJoin = true;\n  }\n  let wrap = findWrapping(outerRange, listType, attrs, range);\n  if (!wrap) return false;\n  if (tr) doWrapInList(tr, range, wrap, doJoin, listType);\n  return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  let content = Fragment.empty;\n  for (let i = wrappers.length - 1; i >= 0; i--) content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n  let found = 0;\n  for (let i = 0; i < wrappers.length; i++) if (wrappers[i].type == listType) found = i + 1;\n  let splitDepth = wrappers.length - found;\n  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),\n    parent = range.parent;\n  for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(i).nodeSize;\n  }\n  return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to,\n      node\n    } = state.selection;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    let grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n      if (dispatch) {\n        let wrap = Fragment.empty;\n        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = Fragment.from($from.node(d).copy(wrap));\n        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        let start = $from.before($from.depth - (depthBefore - 1));\n        let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n        let sel = -1;\n        tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n          if (sel > -1) return false;\n          if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n        });\n        if (sel > -1) tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    let tr = state.tr.delete($from.pos, $to.pos);\n    let types = nextType ? [itemAttrs ? {\n      type: itemType,\n      attrs: itemAttrs\n    } : null, {\n      type: nextType\n    }] : undefined;\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n  let split = splitListItem(itemType, itemAttrs);\n  return (state, dispatch) => {\n    return split(state, dispatch && (tr => {\n      let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n      if (marks) tr.ensureMarks(marks);\n      dispatch(tr);\n    }));\n  };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n    if (!range) return false;\n    if (!dispatch) return true;\n    if ($from.node(range.depth - 1).type == itemType)\n      // Inside a parent list\n      return liftToOuterList(state, dispatch, itemType, range);else\n      // Outer list node\n      return liftOutOfList(state, dispatch, range);\n  };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  let tr = state.tr,\n    end = range.end,\n    endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  const target = liftTarget(range);\n  if (target == null) return false;\n  tr.lift(range, target);\n  let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n  if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type) tr.join($after.pos);\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n  let tr = state.tr,\n    list = range.parent;\n  // Merge the list items into a single big item\n  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n  let $start = tr.doc.resolve(range.start),\n    item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n  let atStart = range.startIndex == 0,\n    atEnd = range.endIndex == list.childCount;\n  let parent = $start.node(-1),\n    indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list)))) return false;\n  let start = $start.pos,\n    end = start + item.nodeSize;\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n    if (!range) return false;\n    let startIndex = range.startIndex;\n    if (startIndex == 0) return false;\n    let parent = range.parent,\n      nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) return false;\n    if (dispatch) {\n      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      let before = range.start,\n        after = range.end;\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n    return true;\n  };\n}\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, splitListItemKeepMarks, wrapInList, wrapRangeInList };","map":{"version":3,"names":["findWrapping","ReplaceAroundStep","canSplit","liftTarget","canJoin","NodeRange","Fragment","Slice","Selection","olDOM","ulDOM","liDOM","orderedList","attrs","order","default","validate","parseDOM","tag","getAttrs","dom","hasAttribute","getAttribute","toDOM","node","start","bulletList","listItem","defining","add","obj","props","copy","prop","addListNodes","nodes","itemContent","listGroup","append","ordered_list","content","group","bullet_list","list_item","wrapInList","listType","arguments","length","undefined","state","dispatch","$from","$to","selection","range","blockRange","tr","wrapRangeInList","scrollIntoView","doJoin","outerRange","doc","depth","type","compatibleContent","startIndex","index","$insert","resolve","endIndex","parent","childCount","end","wrap","doWrapInList","wrappers","joinBefore","empty","i","from","create","step","found","splitDepth","splitPos","e","first","split","child","nodeSize","splitListItem","itemType","itemAttrs","isBlock","sameParent","grandParent","size","indexAfter","depthBefore","d","depthAfter","createAndFill","before","replace","after","sel","nodesBetween","pos","isTextblock","setSelection","near","nextType","contentMatchAt","defaultType","delete","types","splitListItemKeepMarks","marks","storedMarks","parentOffset","ensureMarks","liftListItem","firstChild","liftToOuterList","liftOutOfList","endOfList","target","lift","$after","mapping","map","nodeBefore","nodeAfter","join","list","$start","item","atStart","atEnd","indexBefore","canReplace","sinkListItem","nestedBefore","lastChild","inner","slice"],"sources":["C:/Users/Mitchell/Downloads/Hemming Way App Clone/Hemming Way App Clone/node_modules/prosemirror-schema-list/dist/index.js"],"sourcesContent":["import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to);\n        if (!range)\n            return false;\n        let tr = dispatch ? state.tr : null;\n        if (!wrapRangeInList(tr, range, listType, attrs))\n            return false;\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nTry to wrap the given node range in a list of the given type.\nReturn `true` when this is possible, `false` otherwise. When `tr`\nis non-null, the wrapping is added to that transaction. When it is\n`null`, the function only queries whether the wrapping is\npossible.\n*/\nfunction wrapRangeInList(tr, range, listType, attrs = null) {\n    let doJoin = false, outerRange = range, doc = range.$from.doc;\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n        // Don't do anything if this is the top of the list\n        if (range.$from.index(range.depth - 1) == 0)\n            return false;\n        let $insert = doc.resolve(range.start - 2);\n        outerRange = new NodeRange($insert, $insert, range.depth);\n        if (range.endIndex < range.parent.childCount)\n            range = new NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n        doJoin = true;\n    }\n    let wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap)\n        return false;\n    if (tr)\n        doWrapInList(tr, range, wrap, doJoin, listType);\n    return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!canSplit(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n    let split = splitListItem(itemType, itemAttrs);\n    return (state, dispatch) => {\n        return split(state, dispatch && (tr => {\n            let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n            if (marks)\n                tr.ensureMarks(marks);\n            dispatch(tr);\n        }));\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = liftTarget(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n    if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)\n        tr.join($after.pos);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, splitListItemKeepMarks, wrapInList, wrapRangeInList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}