{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/bullet-list/bullet-list.ts\nimport { mergeAttributes, Node, wrappingInputRule } from \"@tiptap/core\";\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{\n      tag: \"ul\"\n    }];\n  },\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return [\"ul\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => _ref2 => {\n        let {\n          commands,\n          chain\n        } = _ref2;\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\nimport { mergeAttributes as mergeAttributes2, Node as Node2 } from \"@tiptap/core\";\nvar ListItem = Node2.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [{\n      tag: \"li\"\n    }];\n  },\n  renderHTML(_ref3) {\n    let {\n      HTMLAttributes\n    } = _ref3;\n    return [\"li\", mergeAttributes2(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\nimport { Extension } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\nimport { getNodeType } from \"@tiptap/core\";\nvar findListItemPos = (typeOrName, state) => {\n  const {\n    $from\n  } = state.selection;\n  const nodeType = getNodeType(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return {\n    $pos: state.doc.resolve(currentPos),\n    depth: targetDepth\n  };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\nimport { getNodeAtPosition } from \"@tiptap/core\";\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nimport { isAtStartOfNode, isNodeActive } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const {\n    $anchor\n  } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const {\n    $anchor\n  } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\nimport { getNodeType as getNodeType2 } from \"@tiptap/core\";\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = getNodeType2(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const {\n      $anchor\n    } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({\n          node,\n          pos\n        });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({\n      from: $anchor.start() - 1,\n      to: $anchor.end() + 1\n    }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!isNodeActive(editor.state, name)) {\n    return false;\n  }\n  if (!isAtStartOfNode(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nimport { isAtEndOfNode, isNodeActive as isNodeActive2 } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!isNodeActive2(editor.state, name)) {\n    return false;\n  }\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false;\n  }\n  const {\n    selection\n  } = editor.state;\n  const {\n    $from,\n    $to\n  } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const {\n    $anchor\n  } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [{\n        itemName: \"listItem\",\n        wrapperNames: [\"bulletList\", \"orderedList\"]\n      }, {\n        itemName: \"taskItem\",\n        wrapperNames: [\"taskList\"]\n      }]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: _ref4 => {\n        let {\n          editor\n        } = _ref4;\n        let handled = false;\n        this.options.listTypes.forEach(_ref5 => {\n          let {\n            itemName\n          } = _ref5;\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": _ref6 => {\n        let {\n          editor\n        } = _ref6;\n        let handled = false;\n        this.options.listTypes.forEach(_ref7 => {\n          let {\n            itemName\n          } = _ref7;\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: _ref8 => {\n        let {\n          editor\n        } = _ref8;\n        let handled = false;\n        this.options.listTypes.forEach(_ref9 => {\n          let {\n            itemName,\n            wrapperNames\n          } = _ref9;\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": _ref0 => {\n        let {\n          editor\n        } = _ref0;\n        let handled = false;\n        this.options.listTypes.forEach(_ref1 => {\n          let {\n            itemName,\n            wrapperNames\n          } = _ref1;\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\nimport { Extension as Extension2 } from \"@tiptap/core\";\n\n// src/ordered-list/ordered-list.ts\nimport { mergeAttributes as mergeAttributes3, Node as Node3, wrappingInputRule as wrappingInputRule2 } from \"@tiptap/core\";\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = Node3.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"ol\"\n    }];\n  },\n  renderHTML(_ref10) {\n    let {\n      HTMLAttributes\n    } = _ref10;\n    const {\n      start,\n      ...attributesWithoutStart\n    } = HTMLAttributes;\n    return start === 1 ? [\"ol\", mergeAttributes3(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", mergeAttributes3(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => _ref11 => {\n        let {\n          commands,\n          chain\n        } = _ref11;\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = wrappingInputRule2({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        start: +match[1]\n      }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule2({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({\n          start: +match[1],\n          ...this.editor.getAttributes(TextStyleName2)\n        }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\nimport { mergeAttributes as mergeAttributes4, Node as Node4, wrappingInputRule as wrappingInputRule3 } from \"@tiptap/core\";\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = Node4.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: attributes => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: `li[data-type=\"${this.name}\"]`,\n      priority: 51\n    }];\n  },\n  renderHTML(_ref12) {\n    let {\n      node,\n      HTMLAttributes\n    } = _ref12;\n    return [\"li\", mergeAttributes4(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-type\": this.name\n    }), [\"label\", [\"input\", {\n      type: \"checkbox\",\n      checked: node.attrs.checked ? \"checked\" : null\n    }], [\"span\"]], [\"div\", 0]];\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return _ref13 => {\n      let {\n        node,\n        HTMLAttributes,\n        getPos,\n        editor\n      } = _ref13;\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = currentNode => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n      };\n      updateA11Y(node);\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", event => event.preventDefault());\n      checkbox.addEventListener(\"change\", event => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const {\n          checked\n        } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, {\n            scrollIntoView: false\n          }).command(_ref14 => {\n            let {\n              tr\n            } = _ref14;\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...(currentNode == null ? void 0 : currentNode.attrs),\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(_ref15 => {\n        let [key, value] = _ref15;\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(_ref16 => {\n        let [key, value] = _ref16;\n        listItem.setAttribute(key, value);\n      });\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y(updatedNode);\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [wrappingInputRule3({\n      find: inputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        checked: match[match.length - 1] === \"x\"\n      })\n    })];\n  }\n});\n\n// src/task-list/task-list.ts\nimport { mergeAttributes as mergeAttributes5, Node as Node5 } from \"@tiptap/core\";\nvar TaskList = Node5.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{\n      tag: `ul[data-type=\"${this.name}\"]`,\n      priority: 51\n    }];\n  },\n  renderHTML(_ref17) {\n    let {\n      HTMLAttributes\n    } = _ref17;\n    return [\"ul\", mergeAttributes5(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-type\": this.name\n    }), 0];\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => _ref18 => {\n        let {\n          commands\n        } = _ref18;\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = Extension2.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\nexport { BulletList, ListItem, ListKeymap, ListKit, OrderedList, TaskItem, TaskList, bulletListInputRegex, inputRegex, listHelpers_exports as listHelpers, orderedListInputRegex };","map":{"version":3,"names":["mergeAttributes","Node","wrappingInputRule","ListItemName","TextStyleName","bulletListInputRegex","BulletList","create","name","addOptions","itemTypeName","HTMLAttributes","keepMarks","keepAttributes","group","content","options","parseHTML","tag","renderHTML","_ref","addCommands","toggleBulletList","_ref2","commands","chain","toggleList","updateAttributes","editor","getAttributes","run","addKeyboardShortcuts","Mod-Shift-8","addInputRules","inputRule","find","type","mergeAttributes2","Node2","ListItem","bulletListTypeName","orderedListTypeName","defining","_ref3","Enter","splitListItem","Tab","sinkListItem","Shift-Tab","liftListItem","Extension","listHelpers_exports","__export","findListItemPos","getNextListDepth","handleBackspace","handleDelete","hasListBefore","hasListItemAfter","hasListItemBefore","listItemHasSubList","nextListIsDeeper","nextListIsHigher","getNodeType","typeOrName","state","$from","selection","nodeType","schema","currentNode","currentDepth","depth","currentPos","pos","targetDepth","node","$pos","doc","resolve","getNodeAtPosition","listItemPos","isAtStartOfNode","isNodeActive","editorState","parentListTypes","$anchor","previousNodePos","Math","max","previousNode","includes","_a","$targetPos","index","nodeBefore","getNodeType2","hasSubList","descendants","child","undoInputRule","from","to","$listPos","before","listDescendants","push","lastItem","at","$lastItemPos","start","cut","end","joinForward","$prev","prevNode","previousListItemHasSubList","joinItemBackward","isAtEndOfNode","isNodeActive2","listDepth","$to","empty","sameParent","focus","lift","joinBackward","joinItemForward","parentOffset","parent","childCount","nodeAfter","ListKeymap","listTypes","itemName","wrapperNames","Delete","_ref4","handled","forEach","_ref5","nodes","_ref6","_ref7","Backspace","_ref8","_ref9","_ref0","_ref1","Extension2","mergeAttributes3","Node3","wrappingInputRule2","ListItemName2","TextStyleName2","orderedListInputRegex","OrderedList","addAttributes","default","element","hasAttribute","parseInt","getAttribute","_ref10","attributesWithoutStart","toggleOrderedList","_ref11","Mod-Shift-7","match","joinPredicate","attrs","mergeAttributes4","Node4","wrappingInputRule3","inputRegex","TaskItem","nested","taskListTypeName","a11y","checked","keepOnSplit","dataChecked","attributes","priority","_ref12","shortcuts","addNodeView","_ref13","getPos","listItem","document","createElement","checkboxWrapper","checkboxStyler","checkbox","updateA11Y","_b","ariaLabel","checkboxLabel","call","textContent","contentEditable","addEventListener","event","preventDefault","isEditable","onReadOnlyChecked","target","scrollIntoView","command","_ref14","tr","position","nodeAt","setNodeMarkup","Object","entries","_ref15","key","value","setAttribute","dataset","append","_ref16","dom","contentDOM","update","updatedNode","length","mergeAttributes5","Node5","TaskList","_ref17","toggleTaskList","_ref18","Mod-Shift-9","ListKit","addExtensions","extensions","bulletList","configure","listKeymap","orderedList","taskItem","taskList"],"sources":["C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\bullet-list\\bullet-list.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\item\\list-item.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\list-keymap.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\index.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\findListItemPos.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\getNextListDepth.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\handleBackspace.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\hasListBefore.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\hasListItemBefore.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\listItemHasSubList.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\handleDelete.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\nextListIsDeeper.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\nextListIsHigher.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\hasListItemAfter.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\kit\\index.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\ordered-list\\ordered-list.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\task-item\\task-item.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\extension-list\\src\\task-list\\task-list.ts"],"sourcesContent":["import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n","import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n","export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n","import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n","import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * Itâ€™s a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n","import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isnâ€™t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n","import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}