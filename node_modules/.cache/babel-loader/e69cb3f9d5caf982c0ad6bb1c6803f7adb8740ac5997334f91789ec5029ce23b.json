{"ast":null,"code":"// src/Context.tsx\nimport { createContext, useContext, useMemo } from \"react\";\n\n// src/EditorContent.tsx\nimport React, { forwardRef } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar mergeRefs = function () {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ;\n        ref.current = node;\n      }\n    });\n  };\n};\nvar Portals = _ref => {\n  let {\n    contentComponent\n  } = _ref;\n  const renderers = useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: Object.values(renderers)\n  });\n};\nfunction getInstance() {\n  const subscribers = /* @__PURE__ */new Set();\n  let renderers = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    getSnapshot() {\n      return renderers;\n    },\n    getServerSnapshot() {\n      return renderers;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id, renderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id)\n      };\n      subscribers.forEach(subscriber => subscriber());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id) {\n      const nextRenderers = {\n        ...renderers\n      };\n      delete nextRenderers[id];\n      renderers = nextRenderers;\n      subscribers.forEach(subscriber => subscriber());\n    }\n  };\n}\nvar PureEditorContent = class extends React.Component {\n  constructor(props) {\n    var _a;\n    super(props);\n    this.editorContentRef = React.createRef();\n    this.initialized = false;\n    this.state = {\n      hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)\n    };\n  }\n  componentDidMount() {\n    this.init();\n  }\n  componentDidUpdate() {\n    this.init();\n  }\n  init() {\n    const editor = this.props.editor;\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n      const element = this.editorContentRef.current;\n      element.append(...editor.options.element.childNodes);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = getInstance();\n      if (!this.state.hasContentComponentInitialized) {\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true\n              };\n            }\n            return prevState;\n          });\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n          }\n        });\n      }\n      editor.createNodeViews();\n      this.initialized = true;\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    const editor = this.props.editor;\n    if (!editor) {\n      return;\n    }\n    this.initialized = false;\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent();\n    }\n    editor.contentComponent = null;\n    if (!((_a = editor.options.element) == null ? void 0 : _a.firstChild)) {\n      return;\n    }\n    const newElement = document.createElement(\"div\");\n    newElement.append(...editor.options.element.childNodes);\n    editor.setOptions({\n      element: newElement\n    });\n  }\n  render() {\n    const {\n      editor,\n      innerRef,\n      ...rest\n    } = this.props;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(\"div\", {\n        ref: mergeRefs(innerRef, this.editorContentRef),\n        ...rest\n      }), (editor == null ? void 0 : editor.contentComponent) && /* @__PURE__ */jsx(Portals, {\n        contentComponent: editor.contentComponent\n      })]\n    });\n  }\n};\nvar EditorContentWithKey = forwardRef((props, ref) => {\n  const key = React.useMemo(() => {\n    return Math.floor(Math.random() * 4294967295).toString();\n  }, [props.editor]);\n  return React.createElement(PureEditorContent, {\n    key,\n    innerRef: ref,\n    ...props\n  });\n});\nvar EditorContent = React.memo(EditorContentWithKey);\n\n// src/useEditor.ts\nimport { Editor } from \"@tiptap/core\";\nimport { useDebugValue as useDebugValue2, useEffect as useEffect2, useRef, useState as useState2 } from \"react\";\nimport { useSyncExternalStore as useSyncExternalStore2 } from \"use-sync-external-store/shim/index.js\";\n\n// src/useEditorState.ts\nimport deepEqual from \"fast-deep-equal/es6/react.js\";\nimport { useDebugValue, useEffect, useLayoutEffect, useState } from \"react\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\nvar EditorStateManager = class {\n  constructor(initialEditor) {\n    this.transactionNumber = 0;\n    this.lastTransactionNumber = 0;\n    this.subscribers = /* @__PURE__ */new Set();\n    this.editor = initialEditor;\n    this.lastSnapshot = {\n      editor: initialEditor,\n      transactionNumber: 0\n    };\n    this.getSnapshot = this.getSnapshot.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.watch = this.watch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot() {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot;\n    }\n    this.lastTransactionNumber = this.transactionNumber;\n    this.lastSnapshot = {\n      editor: this.editor,\n      transactionNumber: this.transactionNumber\n    };\n    return this.lastSnapshot;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return {\n      editor: null,\n      transactionNumber: 0\n    };\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor) {\n    this.editor = nextEditor;\n    if (this.editor) {\n      const fn = () => {\n        this.transactionNumber += 1;\n        this.subscribers.forEach(callback => callback());\n      };\n      const currentEditor = this.editor;\n      currentEditor.on(\"transaction\", fn);\n      return () => {\n        currentEditor.off(\"transaction\", fn);\n      };\n    }\n    return void 0;\n  }\n};\nfunction useEditorState(options) {\n  var _a;\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor));\n  const selectedState = useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) != null ? _a : deepEqual);\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor);\n  }, [options.editor, editorStateManager]);\n  useDebugValue(selectedState);\n  return selectedState;\n}\n\n// src/useEditor.ts\nvar isDev = process.env.NODE_ENV !== \"production\";\nvar isSSR = typeof window === \"undefined\";\nvar isNext = isSSR || Boolean(typeof window !== \"undefined\" && window.next);\nvar EditorInstanceManager = class _EditorInstanceManager {\n  constructor(options) {\n    /**\n     * The current editor instance.\n     */\n    this.editor = null;\n    /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */\n    this.subscriptions = /* @__PURE__ */new Set();\n    /**\n     * Whether the editor has been mounted.\n     */\n    this.isComponentMounted = false;\n    /**\n     * The most recent dependencies array.\n     */\n    this.previousDeps = null;\n    /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */\n    this.instanceId = \"\";\n    this.options = options;\n    this.subscriptions = /* @__PURE__ */new Set();\n    this.setEditor(this.getInitialEditor());\n    this.scheduleDestroy();\n    this.getEditor = this.getEditor.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n    this.scheduleDestroy = this.scheduleDestroy.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this.createEditor = this.createEditor.bind(this);\n  }\n  setEditor(editor) {\n    this.editor = editor;\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.subscriptions.forEach(cb => cb());\n  }\n  getInitialEditor() {\n    if (this.options.current.immediatelyRender === void 0) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          throw new Error(\"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\");\n        }\n        return null;\n      }\n      return this.createEditor();\n    }\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      throw new Error(\"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\");\n    }\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor();\n    }\n    return null;\n  }\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  createEditor() {\n    var _this = this;\n    const optionsToApply = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: function () {\n        var _a, _b;\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return (_b = (_a = _this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onBlur: function () {\n        var _a, _b;\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return (_b = (_a = _this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onCreate: function () {\n        var _a, _b;\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n        return (_b = (_a = _this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDestroy: function () {\n        var _a, _b;\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return (_b = (_a = _this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onFocus: function () {\n        var _a, _b;\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n        return (_b = (_a = _this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onSelectionUpdate: function () {\n        var _a, _b;\n        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          args[_key7] = arguments[_key7];\n        }\n        return (_b = (_a = _this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onTransaction: function () {\n        var _a, _b;\n        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n          args[_key8] = arguments[_key8];\n        }\n        return (_b = (_a = _this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onUpdate: function () {\n        var _a, _b;\n        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n          args[_key9] = arguments[_key9];\n        }\n        return (_b = (_a = _this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onContentError: function () {\n        var _a, _b;\n        for (var _len0 = arguments.length, args = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {\n          args[_key0] = arguments[_key0];\n        }\n        return (_b = (_a = _this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDrop: function () {\n        var _a, _b;\n        for (var _len1 = arguments.length, args = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {\n          args[_key1] = arguments[_key1];\n        }\n        return (_b = (_a = _this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onPaste: function () {\n        var _a, _b;\n        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n          args[_key10] = arguments[_key10];\n        }\n        return (_b = (_a = _this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDelete: function () {\n        var _a, _b;\n        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n          args[_key11] = arguments[_key11];\n        }\n        return (_b = (_a = _this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);\n      }\n    };\n    const editor = new Editor(optionsToApply);\n    return editor;\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getEditor() {\n    return this.editor;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return null;\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange) {\n    this.subscriptions.add(onStoreChange);\n    return () => {\n      this.subscriptions.delete(onStoreChange);\n    };\n  }\n  static compareOptions(a, b) {\n    return Object.keys(a).every(key => {\n      if ([\"onCreate\", \"onBeforeCreate\", \"onDestroy\", \"onUpdate\", \"onTransaction\", \"onFocus\", \"onBlur\", \"onSelectionUpdate\", \"onContentError\", \"onDrop\", \"onPaste\"].includes(key)) {\n        return true;\n      }\n      if (key === \"extensions\" && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false;\n        }\n        return a.extensions.every((extension, index) => {\n          var _a;\n          if (extension !== ((_a = b.extensions) == null ? void 0 : _a[index])) {\n            return false;\n          }\n          return true;\n        });\n      }\n      if (a[key] !== b[key]) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps) {\n    return () => {\n      this.isComponentMounted = true;\n      clearTimeout(this.scheduledDestructionTimeout);\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable\n          });\n        }\n      } else {\n        this.refreshEditorInstance(deps);\n      }\n      return () => {\n        this.isComponentMounted = false;\n        this.scheduleDestroy();\n      };\n    };\n  }\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  refreshEditorInstance(deps) {\n    if (this.editor && !this.editor.isDestroyed) {\n      if (this.previousDeps === null) {\n        this.previousDeps = deps;\n        return;\n      }\n      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);\n      if (depsAreEqual) {\n        return;\n      }\n    }\n    if (this.editor && !this.editor.isDestroyed) {\n      this.editor.destroy();\n    }\n    this.setEditor(this.createEditor());\n    this.previousDeps = deps;\n  }\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  scheduleDestroy() {\n    const currentInstanceId = this.instanceId;\n    const currentEditor = this.editor;\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        if (currentEditor) {\n          currentEditor.setOptions(this.options.current);\n        }\n        return;\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy();\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null);\n        }\n      }\n    }, 1);\n  }\n};\nfunction useEditor() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const mostRecentOptions = useRef(options);\n  mostRecentOptions.current = options;\n  const [instanceManager] = useState2(() => new EditorInstanceManager(mostRecentOptions));\n  const editor = useSyncExternalStore2(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n  useDebugValue2(editor);\n  useEffect2(instanceManager.onRender(deps));\n  useEditorState({\n    editor,\n    selector: _ref2 => {\n      let {\n        transactionNumber\n      } = _ref2;\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {\n        return null;\n      }\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0;\n      }\n      return transactionNumber + 1;\n    }\n  });\n  return editor;\n}\n\n// src/Context.tsx\nimport { jsx as jsx2, jsxs as jsxs2 } from \"react/jsx-runtime\";\nvar EditorContext = createContext({\n  editor: null\n});\nvar EditorConsumer = EditorContext.Consumer;\nvar useCurrentEditor = () => useContext(EditorContext);\nfunction EditorProvider(_ref3) {\n  let {\n    children,\n    slotAfter,\n    slotBefore,\n    editorContainerProps = {},\n    ...editorOptions\n  } = _ref3;\n  const editor = useEditor(editorOptions);\n  const contextValue = useMemo(() => ({\n    editor\n  }), [editor]);\n  if (!editor) {\n    return null;\n  }\n  return /* @__PURE__ */jsxs2(EditorContext.Provider, {\n    value: contextValue,\n    children: [slotBefore, /* @__PURE__ */jsx2(EditorConsumer, {\n      children: _ref4 => {\n        let {\n          editor: currentEditor\n        } = _ref4;\n        return /* @__PURE__ */jsx2(EditorContent, {\n          editor: currentEditor,\n          ...editorContainerProps\n        });\n      }\n    }), children, slotAfter]\n  });\n}\n\n// src/useReactNodeView.ts\nimport { createContext as createContext2, createElement, useContext as useContext2 } from \"react\";\nvar ReactNodeViewContext = createContext2({\n  onDragStart: () => {},\n  nodeViewContentChildren: void 0,\n  nodeViewContentRef: () => {}\n});\nvar ReactNodeViewContentProvider = _ref5 => {\n  let {\n    children,\n    content\n  } = _ref5;\n  return createElement(ReactNodeViewContext.Provider, {\n    value: {\n      nodeViewContentChildren: content\n    }\n  }, children);\n};\nvar useReactNodeView = () => useContext2(ReactNodeViewContext);\n\n// src/NodeViewContent.tsx\nimport { jsx as jsx3 } from \"react/jsx-runtime\";\nfunction NodeViewContent(_ref6) {\n  let {\n    as: Tag = \"div\",\n    ...props\n  } = _ref6;\n  const {\n    nodeViewContentRef,\n    nodeViewContentChildren\n  } = useReactNodeView();\n  return (\n    // @ts-ignore\n    /* @__PURE__ */\n    jsx3(Tag, {\n      ...props,\n      ref: nodeViewContentRef,\n      \"data-node-view-content\": \"\",\n      style: {\n        whiteSpace: \"pre-wrap\",\n        ...props.style\n      },\n      children: nodeViewContentChildren\n    })\n  );\n}\n\n// src/NodeViewWrapper.tsx\nimport React3 from \"react\";\nimport { jsx as jsx4 } from \"react/jsx-runtime\";\nvar NodeViewWrapper = React3.forwardRef((props, ref) => {\n  const {\n    onDragStart\n  } = useReactNodeView();\n  const Tag = props.as || \"div\";\n  return (\n    // @ts-ignore\n    /* @__PURE__ */\n    jsx4(Tag, {\n      ...props,\n      ref,\n      \"data-node-view-wrapper\": \"\",\n      onDragStart,\n      style: {\n        whiteSpace: \"normal\",\n        ...props.style\n      }\n    })\n  );\n});\n\n// src/ReactMarkViewRenderer.tsx\nimport { MarkView } from \"@tiptap/core\";\nimport React4 from \"react\";\n\n// src/ReactRenderer.tsx\nimport { version as reactVersion } from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { jsx as jsx5 } from \"react/jsx-runtime\";\nfunction isClassComponent(Component) {\n  return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\nfunction isForwardRefComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\nfunction isMemoComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\nfunction canReceiveRef(Component) {\n  if (isClassComponent(Component)) {\n    return true;\n  }\n  if (isForwardRefComponent(Component)) {\n    return true;\n  }\n  if (isMemoComponent(Component)) {\n    const wrappedComponent = Component.type;\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n    }\n  }\n  return false;\n}\nfunction isReact19Plus() {\n  try {\n    if (reactVersion) {\n      const majorVersion = parseInt(reactVersion.split(\".\")[0], 10);\n      return majorVersion >= 19;\n    }\n  } catch {}\n  return false;\n}\nvar ReactRenderer = class {\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(component, _ref7) {\n    let {\n      editor,\n      props = {},\n      as = \"div\",\n      className = \"\"\n    } = _ref7;\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 4294967295).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add(\"react-renderer\");\n    if (className) {\n      this.element.classList.add(...className.split(\" \"));\n    }\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render();\n      });\n    } else {\n      queueMicrotask(() => {\n        this.render();\n      });\n    }\n  }\n  /**\n   * Render the React component.\n   */\n  render() {\n    var _a;\n    const Component = this.component;\n    const props = this.props;\n    const editor = this.editor;\n    const isReact19 = isReact19Plus();\n    const componentCanReceiveRef = canReceiveRef(Component);\n    const elementProps = {\n      ...props\n    };\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref;\n    }\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      elementProps.ref = ref => {\n        this.ref = ref;\n      };\n    }\n    this.reactElement = /* @__PURE__ */jsx5(Component, {\n      ...elementProps\n    });\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);\n  }\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    this.render();\n  }\n  /**\n   * Destroy the React component.\n   */\n  destroy() {\n    var _a;\n    const editor = this.editor;\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);\n  }\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes) {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key]);\n    });\n  }\n};\n\n// src/ReactMarkViewRenderer.tsx\nimport { jsx as jsx6 } from \"react/jsx-runtime\";\nvar ReactMarkViewContext = React4.createContext({\n  markViewContentRef: () => {}\n});\nvar MarkViewContent = props => {\n  const {\n    as: Tag = \"span\",\n    ...rest\n  } = props;\n  const {\n    markViewContentRef\n  } = React4.useContext(ReactMarkViewContext);\n  return (\n    // @ts-ignore\n    /* @__PURE__ */\n    jsx6(Tag, {\n      ...rest,\n      ref: markViewContentRef,\n      \"data-mark-view-content\": \"\"\n    })\n  );\n};\nvar ReactMarkView = class extends MarkView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    this.didMountContentDomElement = false;\n    const {\n      as = \"span\",\n      attrs,\n      className = \"\"\n    } = options || {};\n    const componentProps = {\n      ...props,\n      updateAttributes: this.updateAttributes.bind(this)\n    };\n    this.contentDOMElement = document.createElement(\"span\");\n    const markViewContentRef = el => {\n      if (el && this.contentDOMElement && el.firstChild !== this.contentDOMElement) {\n        el.appendChild(this.contentDOMElement);\n        this.didMountContentDomElement = true;\n      }\n    };\n    const context = {\n      markViewContentRef\n    };\n    const ReactMarkViewProvider = React4.memo(componentProps2 => {\n      return /* @__PURE__ */jsx6(ReactMarkViewContext.Provider, {\n        value: context,\n        children: React4.createElement(component, componentProps2)\n      });\n    });\n    ReactMarkViewProvider.displayName = \"ReactNodeView\";\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim()\n    });\n    if (attrs) {\n      this.renderer.updateAttributes(attrs);\n    }\n  }\n  get dom() {\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    if (!this.didMountContentDomElement) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n};\nfunction ReactMarkViewRenderer(component) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return props => new ReactMarkView(component, props, options);\n}\n\n// src/ReactNodeViewRenderer.tsx\nimport { getRenderedAttributes, NodeView } from \"@tiptap/core\";\nimport { createElement as createElement2, createRef, memo } from \"react\";\nimport { jsx as jsx7 } from \"react/jsx-runtime\";\nvar ReactNodeView = class extends NodeView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n      }\n      this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n      this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n      this.contentDOMElement.style.whiteSpace = \"inherit\";\n      const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n      if (!contentTarget) {\n        return;\n      }\n      contentTarget.appendChild(this.contentDOMElement);\n    }\n  }\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    var _this2 = this;\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: function () {\n        let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this2.updateAttributes(attributes);\n      },\n      deleteNode: () => this.deleteNode(),\n      ref: createRef()\n    };\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = string => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n    const onDragStart = this.onDragStart.bind(this);\n    const nodeViewContentRef = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        if (element.hasAttribute(\"data-node-view-wrapper\")) {\n          element.removeAttribute(\"data-node-view-wrapper\");\n        }\n        element.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = {\n      onDragStart,\n      nodeViewContentRef\n    };\n    const Component = this.component;\n    const ReactNodeViewProvider = memo(componentProps => {\n      return /* @__PURE__ */jsx7(ReactNodeViewContext.Provider, {\n        value: context,\n        children: createElement2(Component, componentProps)\n      });\n    });\n    ReactNodeViewProvider.displayName = \"ReactNodeView\";\n    let as = this.node.isInline ? \"span\" : \"div\";\n    if (this.options.as) {\n      as = this.options.as;\n    }\n    const {\n      className = \"\"\n    } = this.options;\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim()\n    });\n    this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.updateElementAttributes();\n  }\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    var _a;\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n      throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n    }\n    return this.renderer.element;\n  }\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const {\n      from,\n      to\n    } = this.editor.state.selection;\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return;\n      }\n      this.selectNode();\n    } else {\n      if (!this.renderer.props.selected) {\n        return;\n      }\n      this.deselectNode();\n    }\n  }\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node, decorations, innerDecorations) {\n    const rerenderComponent = props => {\n      this.renderer.updateProps(props);\n      if (typeof this.options.attrs === \"function\") {\n        this.updateElementAttributes();\n      }\n    };\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (typeof this.options.update === \"function\") {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      const oldInnerDecorations = this.innerDecorations;\n      this.node = node;\n      this.decorations = decorations;\n      this.innerDecorations = innerDecorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({\n          node,\n          decorations,\n          innerDecorations\n        })\n      });\n    }\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    this.innerDecorations = innerDecorations;\n    rerenderComponent({\n      node,\n      decorations,\n      innerDecorations\n    });\n    return true;\n  }\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy();\n    this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.contentDOMElement = null;\n  }\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj = {};\n      if (typeof this.options.attrs === \"function\") {\n        const extensionAttributes = this.editor.extensionManager.attributes;\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes);\n        attrsObj = this.options.attrs({\n          node: this.node,\n          HTMLAttributes\n        });\n      } else {\n        attrsObj = this.options.attrs;\n      }\n      this.renderer.updateAttributes(attrsObj);\n    }\n  }\n};\nfunction ReactNodeViewRenderer(component, options) {\n  return props => {\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new ReactNodeView(component, props, options);\n  };\n}\n\n// src/index.ts\nexport * from \"@tiptap/core\";\nexport { EditorConsumer, EditorContent, EditorContext, EditorProvider, MarkViewContent, NodeViewContent, NodeViewWrapper, PureEditorContent, ReactMarkView, ReactMarkViewContext, ReactMarkViewRenderer, ReactNodeView, ReactNodeViewContentProvider, ReactNodeViewContext, ReactNodeViewRenderer, ReactRenderer, useCurrentEditor, useEditor, useEditorState, useReactNodeView };","map":{"version":3,"names":["createContext","useContext","useMemo","React","forwardRef","ReactDOM","useSyncExternalStore","Fragment","jsx","jsxs","mergeRefs","_len","arguments","length","refs","Array","_key","node","forEach","ref","current","Portals","_ref","contentComponent","renderers","subscribe","getSnapshot","getServerSnapshot","children","Object","values","getInstance","subscribers","Set","callback","add","delete","setRenderer","id","renderer","createPortal","reactElement","element","subscriber","removeRenderer","nextRenderers","PureEditorContent","Component","constructor","props","_a","editorContentRef","createRef","initialized","state","hasContentComponentInitialized","Boolean","editor","componentDidMount","init","componentDidUpdate","isDestroyed","options","append","childNodes","setOptions","unsubscribeToContentComponent","setState","prevState","createNodeViews","componentWillUnmount","view","setProps","nodeViews","firstChild","newElement","document","createElement","render","innerRef","rest","EditorContentWithKey","key","Math","floor","random","toString","EditorContent","memo","Editor","useDebugValue","useDebugValue2","useEffect","useEffect2","useRef","useState","useState2","useSyncExternalStore2","deepEqual","useLayoutEffect","useSyncExternalStoreWithSelector","useIsomorphicLayoutEffect","window","EditorStateManager","initialEditor","transactionNumber","lastTransactionNumber","lastSnapshot","bind","watch","nextEditor","fn","currentEditor","on","off","useEditorState","editorStateManager","selectedState","selector","equalityFn","isDev","process","env","NODE_ENV","isSSR","isNext","next","EditorInstanceManager","_EditorInstanceManager","subscriptions","isComponentMounted","previousDeps","instanceId","setEditor","getInitialEditor","scheduleDestroy","getEditor","refreshEditorInstance","onRender","createEditor","slice","cb","immediatelyRender","Error","_this","optionsToApply","onBeforeCreate","_b","_len2","args","_key2","call","onBlur","_len3","_key3","onCreate","_len4","_key4","onDestroy","_len5","_key5","onFocus","_len6","_key6","onSelectionUpdate","_len7","_key7","onTransaction","_len8","_key8","onUpdate","_len9","_key9","onContentError","_len0","_key0","onDrop","_len1","_key1","onPaste","_len10","_key10","onDelete","_len11","_key11","onStoreChange","compareOptions","a","b","keys","every","includes","extensions","extension","index","deps","clearTimeout","scheduledDestructionTimeout","editable","isEditable","depsAreEqual","dep","destroy","currentInstanceId","setTimeout","useEditor","undefined","mostRecentOptions","instanceManager","_ref2","shouldRerenderOnTransaction","jsx2","jsxs2","EditorContext","EditorConsumer","Consumer","useCurrentEditor","EditorProvider","_ref3","slotAfter","slotBefore","editorContainerProps","editorOptions","contextValue","Provider","value","_ref4","createContext2","useContext2","ReactNodeViewContext","onDragStart","nodeViewContentChildren","nodeViewContentRef","ReactNodeViewContentProvider","_ref5","content","useReactNodeView","jsx3","NodeViewContent","_ref6","as","Tag","style","whiteSpace","React3","jsx4","NodeViewWrapper","MarkView","React4","version","reactVersion","flushSync","jsx5","isClassComponent","prototype","isReactComponent","isForwardRefComponent","$$typeof","description","isMemoComponent","canReceiveRef","wrappedComponent","type","isReact19Plus","majorVersion","parseInt","split","ReactRenderer","component","_ref7","className","classList","isInitialized","queueMicrotask","isReact19","componentCanReceiveRef","elementProps","updateProps","updateAttributes","attributes","setAttribute","jsx6","ReactMarkViewContext","markViewContentRef","MarkViewContent","ReactMarkView","didMountContentDomElement","attrs","componentProps","contentDOMElement","el","appendChild","context","ReactMarkViewProvider","componentProps2","displayName","mark","name","trim","dom","contentDOM","ReactMarkViewRenderer","getRenderedAttributes","NodeView","createElement2","jsx7","ReactNodeView","isLeaf","contentDOMElementTag","isInline","dataset","nodeViewContentReact","nodeViewWrapper","contentTarget","querySelector","mount","_this2","decorations","innerDecorations","selected","HTMLAttributes","getPos","deleteNode","capitalizeFirstChar","string","charAt","toUpperCase","substring","hasAttribute","removeAttribute","ReactNodeViewProvider","handleSelectionUpdate","updateElementAttributes","firstElementChild","from","to","selection","pos","nodeSize","selectNode","deselectNode","update","rerenderComponent","oldNode","oldDecorations","oldInnerDecorations","newNode","newDecorations","remove","attrsObj","extensionAttributes","extensionManager","ReactNodeViewRenderer"],"sources":["C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\Context.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\EditorContent.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\useEditor.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\useEditorState.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\useReactNodeView.ts","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\NodeViewContent.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\NodeViewWrapper.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\ReactMarkViewRenderer.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\ReactRenderer.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\ReactNodeViewRenderer.tsx","C:\\Users\\Mitchell\\Downloads\\Hemming Way App Clone\\Hemming Way App Clone\\node_modules\\@tiptap\\react\\src\\index.ts"],"sourcesContent":["import type { Editor } from '@tiptap/core'\nimport type { HTMLAttributes, ReactNode } from 'react'\nimport React, { createContext, useContext, useMemo } from 'react'\n\nimport { EditorContent } from './EditorContent.js'\nimport type { UseEditorOptions } from './useEditor.js'\nimport { useEditor } from './useEditor.js'\n\nexport type EditorContextValue = {\n  editor: Editor | null\n}\n\nexport const EditorContext = createContext<EditorContextValue>({\n  editor: null,\n})\n\nexport const EditorConsumer = EditorContext.Consumer\n\n/**\n * A hook to get the current editor instance.\n */\nexport const useCurrentEditor = () => useContext(EditorContext)\n\nexport type EditorProviderProps = {\n  children?: ReactNode\n  slotBefore?: ReactNode\n  slotAfter?: ReactNode\n  editorContainerProps?: HTMLAttributes<HTMLDivElement>\n} & UseEditorOptions\n\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nexport function EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}: EditorProviderProps) {\n  const editor = useEditor(editorOptions)\n  const contextValue = useMemo(() => ({ editor }), [editor])\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <EditorContext.Provider value={contextValue}>\n      {slotBefore}\n      <EditorConsumer>\n        {({ editor: currentEditor }) => <EditorContent editor={currentEditor} {...editorContainerProps} />}\n      </EditorConsumer>\n      {children}\n      {slotAfter}\n    </EditorContext.Provider>\n  )\n}\n","import type { Editor } from '@tiptap/core'\nimport type { ForwardedRef, HTMLProps, LegacyRef, MutableRefObject } from 'react'\nimport React, { forwardRef } from 'react'\nimport ReactDOM from 'react-dom'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport type { ContentComponent, EditorWithContentComponent } from './Editor.js'\nimport type { ReactRenderer } from './ReactRenderer.js'\n\nconst mergeRefs = <T extends HTMLDivElement>(...refs: Array<MutableRefObject<T> | LegacyRef<T> | undefined>) => {\n  return (node: T) => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node)\n      } else if (ref) {\n        ;(ref as MutableRefObject<T | null>).current = node\n      }\n    })\n  }\n}\n\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals: React.FC<{ contentComponent: ContentComponent }> = ({ contentComponent }) => {\n  // For performance reasons, we render the node view portals on state changes only\n  const renderers = useSyncExternalStore(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot,\n  )\n\n  // This allows us to directly render the portals without any additional wrapper\n  return <>{Object.values(renderers)}</>\n}\n\nexport interface EditorContentProps extends HTMLProps<HTMLDivElement> {\n  editor: Editor | null\n  innerRef?: ForwardedRef<HTMLDivElement | null>\n}\n\nfunction getInstance(): ContentComponent {\n  const subscribers = new Set<() => void>()\n  let renderers: Record<string, React.ReactPortal> = {}\n\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback: () => void) {\n      subscribers.add(callback)\n      return () => {\n        subscribers.delete(callback)\n      }\n    },\n    getSnapshot() {\n      return renderers\n    },\n    getServerSnapshot() {\n      return renderers\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id: string, renderer: ReactRenderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id),\n      }\n\n      subscribers.forEach(subscriber => subscriber())\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id: string) {\n      const nextRenderers = { ...renderers }\n\n      delete nextRenderers[id]\n      renderers = nextRenderers\n      subscribers.forEach(subscriber => subscriber())\n    },\n  }\n}\n\nexport class PureEditorContent extends React.Component<\n  EditorContentProps,\n  { hasContentComponentInitialized: boolean }\n> {\n  editorContentRef: React.RefObject<any>\n\n  initialized: boolean\n\n  unsubscribeToContentComponent?: () => void\n\n  constructor(props: EditorContentProps) {\n    super(props)\n    this.editorContentRef = React.createRef()\n    this.initialized = false\n\n    this.state = {\n      hasContentComponentInitialized: Boolean((props.editor as EditorWithContentComponent | null)?.contentComponent),\n    }\n  }\n\n  componentDidMount() {\n    this.init()\n  }\n\n  componentDidUpdate() {\n    this.init()\n  }\n\n  init() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return\n      }\n\n      const element = this.editorContentRef.current\n\n      element.append(...editor.options.element.childNodes)\n\n      editor.setOptions({\n        element,\n      })\n\n      editor.contentComponent = getInstance()\n\n      // Has the content component been initialized?\n      if (!this.state.hasContentComponentInitialized) {\n        // Subscribe to the content component\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true,\n              }\n            }\n            return prevState\n          })\n\n          // Unsubscribe to previous content component\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent()\n          }\n        })\n      }\n\n      editor.createNodeViews()\n\n      this.initialized = true\n    }\n  }\n\n  componentWillUnmount() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (!editor) {\n      return\n    }\n\n    this.initialized = false\n\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {},\n      })\n    }\n\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent()\n    }\n\n    editor.contentComponent = null\n\n    if (!editor.options.element?.firstChild) {\n      return\n    }\n\n    // TODO using the new editor.mount method might allow us to remove this\n    const newElement = document.createElement('div')\n\n    newElement.append(...editor.options.element.childNodes)\n\n    editor.setOptions({\n      element: newElement,\n    })\n  }\n\n  render() {\n    const { editor, innerRef, ...rest } = this.props\n\n    return (\n      <>\n        <div ref={mergeRefs(innerRef, this.editorContentRef)} {...rest} />\n        {/* @ts-ignore */}\n        {editor?.contentComponent && <Portals contentComponent={editor.contentComponent} />}\n      </>\n    )\n  }\n}\n\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = forwardRef<HTMLDivElement, EditorContentProps>(\n  (props: Omit<EditorContentProps, 'innerRef'>, ref) => {\n    const key = React.useMemo(() => {\n      return Math.floor(Math.random() * 0xffffffff).toString()\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.editor])\n\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return React.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props,\n    })\n  },\n)\n\nexport const EditorContent = React.memo(EditorContentWithKey)\n","import { type EditorOptions, Editor } from '@tiptap/core'\nimport type { DependencyList, MutableRefObject } from 'react'\nimport { useDebugValue, useEffect, useRef, useState } from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport { useEditorState } from './useEditorState.js'\n\n// @ts-ignore\nconst isDev = process.env.NODE_ENV !== 'production'\nconst isSSR = typeof window === 'undefined'\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && (window as any).next)\n\n/**\n * The options for the `useEditor` hook.\n */\nexport type UseEditorOptions = Partial<EditorOptions> & {\n  /**\n   * Whether to render the editor on the first render.\n   * If client-side rendering, set this to `true`.\n   * If server-side rendering, set this to `false`.\n   * @default true\n   */\n  immediatelyRender?: boolean\n  /**\n   * Whether to re-render the editor on each transaction.\n   * This is legacy behavior that will be removed in future versions.\n   * @default false\n   */\n  shouldRerenderOnTransaction?: boolean\n}\n\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n  /**\n   * The current editor instance.\n   */\n  private editor: Editor | null = null\n\n  /**\n   * The most recent options to apply to the editor.\n   */\n  private options: MutableRefObject<UseEditorOptions>\n\n  /**\n   * The subscriptions to notify when the editor instance\n   * has been created or destroyed.\n   */\n  private subscriptions = new Set<() => void>()\n\n  /**\n   * A timeout to destroy the editor if it was not mounted within a time frame.\n   */\n  private scheduledDestructionTimeout: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * Whether the editor has been mounted.\n   */\n  private isComponentMounted = false\n\n  /**\n   * The most recent dependencies array.\n   */\n  private previousDeps: DependencyList | null = null\n\n  /**\n   * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n   */\n  public instanceId = ''\n\n  constructor(options: MutableRefObject<UseEditorOptions>) {\n    this.options = options\n    this.subscriptions = new Set<() => void>()\n    this.setEditor(this.getInitialEditor())\n    this.scheduleDestroy()\n\n    this.getEditor = this.getEditor.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this)\n    this.scheduleDestroy = this.scheduleDestroy.bind(this)\n    this.onRender = this.onRender.bind(this)\n    this.createEditor = this.createEditor.bind(this)\n  }\n\n  private setEditor(editor: Editor | null) {\n    this.editor = editor\n    this.instanceId = Math.random().toString(36).slice(2, 9)\n\n    // Notify all subscribers that the editor instance has been created\n    this.subscriptions.forEach(cb => cb())\n  }\n\n  private getInitialEditor() {\n    if (this.options.current.immediatelyRender === undefined) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          /**\n           * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n           * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n           */\n          throw new Error(\n            'Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.',\n          )\n        }\n\n        // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n        return null\n      }\n\n      // Default to immediately rendering when client-side rendering\n      return this.createEditor()\n    }\n\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n      throw new Error(\n        'Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.',\n      )\n    }\n\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor()\n    }\n\n    return null\n  }\n\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  private createEditor(): Editor {\n    const optionsToApply: Partial<EditorOptions> = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => this.options.current.onBeforeCreate?.(...args),\n      onBlur: (...args) => this.options.current.onBlur?.(...args),\n      onCreate: (...args) => this.options.current.onCreate?.(...args),\n      onDestroy: (...args) => this.options.current.onDestroy?.(...args),\n      onFocus: (...args) => this.options.current.onFocus?.(...args),\n      onSelectionUpdate: (...args) => this.options.current.onSelectionUpdate?.(...args),\n      onTransaction: (...args) => this.options.current.onTransaction?.(...args),\n      onUpdate: (...args) => this.options.current.onUpdate?.(...args),\n      onContentError: (...args) => this.options.current.onContentError?.(...args),\n      onDrop: (...args) => this.options.current.onDrop?.(...args),\n      onPaste: (...args) => this.options.current.onPaste?.(...args),\n      onDelete: (...args) => this.options.current.onDelete?.(...args),\n    }\n    const editor = new Editor(optionsToApply)\n\n    // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n\n    return editor\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getEditor(): Editor | null {\n    return this.editor\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): null {\n    return null\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange: () => void) {\n    this.subscriptions.add(onStoreChange)\n\n    return () => {\n      this.subscriptions.delete(onStoreChange)\n    }\n  }\n\n  static compareOptions(a: UseEditorOptions, b: UseEditorOptions) {\n    return (Object.keys(a) as (keyof UseEditorOptions)[]).every(key => {\n      if (\n        [\n          'onCreate',\n          'onBeforeCreate',\n          'onDestroy',\n          'onUpdate',\n          'onTransaction',\n          'onFocus',\n          'onBlur',\n          'onSelectionUpdate',\n          'onContentError',\n          'onDrop',\n          'onPaste',\n        ].includes(key)\n      ) {\n        // we don't want to compare callbacks, they are always different and only registered once\n        return true\n      }\n\n      // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n      if (key === 'extensions' && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false\n        }\n        return a.extensions.every((extension, index) => {\n          if (extension !== b.extensions?.[index]) {\n            return false\n          }\n          return true\n        })\n      }\n      if (a[key] !== b[key]) {\n        // if any of the options have changed, we should update the editor options\n        return false\n      }\n      return true\n    })\n  }\n\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps: DependencyList) {\n    // The returned callback will run on each render\n    return () => {\n      this.isComponentMounted = true\n      // Cleanup any scheduled destructions, since we are currently rendering\n      clearTimeout(this.scheduledDestructionTimeout)\n\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n        if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          // But, the options are different, so we need to update the editor options\n          // Still, this is faster than re-creating the editor\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable,\n          })\n        }\n      } else {\n        // When the editor:\n        // - does not yet exist\n        // - is destroyed\n        // - the deps array changes\n        // We need to destroy the editor instance and re-initialize it\n        this.refreshEditorInstance(deps)\n      }\n\n      return () => {\n        this.isComponentMounted = false\n        this.scheduleDestroy()\n      }\n    }\n  }\n\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  private refreshEditorInstance(deps: DependencyList) {\n    if (this.editor && !this.editor.isDestroyed) {\n      // Editor instance already exists\n      if (this.previousDeps === null) {\n        // If lastDeps has not yet been initialized, reuse the current editor instance\n        this.previousDeps = deps\n        return\n      }\n      const depsAreEqual =\n        this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index])\n\n      if (depsAreEqual) {\n        // deps exist and are equal, no need to recreate\n        return\n      }\n    }\n\n    if (this.editor && !this.editor.isDestroyed) {\n      // Destroy the editor instance if it exists\n      this.editor.destroy()\n    }\n\n    this.setEditor(this.createEditor())\n\n    // Update the lastDeps to the current deps\n    this.previousDeps = deps\n  }\n\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  private scheduleDestroy() {\n    const currentInstanceId = this.instanceId\n    const currentEditor = this.editor\n\n    // Wait two ticks to see if the component is still mounted\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n        if (currentEditor) {\n          // just re-apply options as they might have changed\n          currentEditor.setOptions(this.options.current)\n        }\n        return\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy()\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null)\n        }\n      }\n      // This allows the effect to run again between ticks\n      // which may save us from having to re-create the editor\n    }, 1)\n  }\n}\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(\n  options: UseEditorOptions & { immediatelyRender: false },\n  deps?: DependencyList,\n): Editor | null\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(options: UseEditorOptions, deps?: DependencyList): Editor\n\nexport function useEditor(options: UseEditorOptions = {}, deps: DependencyList = []): Editor | null {\n  const mostRecentOptions = useRef(options)\n\n  mostRecentOptions.current = options\n\n  const [instanceManager] = useState(() => new EditorInstanceManager(mostRecentOptions))\n\n  const editor = useSyncExternalStore(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot,\n  )\n\n  useDebugValue(editor)\n\n  // This effect will handle creating/updating the editor instance\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(instanceManager.onRender(deps))\n\n  // The default behavior is to re-render on each transaction\n  // This is legacy behavior that will be removed in future versions\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === undefined) {\n        // This will prevent the editor from re-rendering on each transaction\n        return null\n      }\n\n      // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0\n      }\n      return transactionNumber + 1\n    },\n  })\n\n  return editor\n}\n","import type { Editor } from '@tiptap/core'\nimport deepEqual from 'fast-deep-equal/es6/react.js'\nimport { useDebugValue, useEffect, useLayoutEffect, useState } from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nexport type EditorStateSnapshot<TEditor extends Editor | null = Editor | null> = {\n  editor: TEditor\n  transactionNumber: number\n}\n\nexport type UseEditorStateOptions<TSelectorResult, TEditor extends Editor | null = Editor | null> = {\n  /**\n   * The editor instance.\n   */\n  editor: TEditor\n  /**\n   * A selector function to determine the value to compare for re-rendering.\n   */\n  selector: (context: EditorStateSnapshot<TEditor>) => TSelectorResult\n  /**\n   * A custom equality function to determine if the editor should re-render.\n   * @default `deepEqual` from `fast-deep-equal`\n   */\n  equalityFn?: (a: TSelectorResult, b: TSelectorResult | null) => boolean\n}\n\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager<TEditor extends Editor | null = Editor | null> {\n  private transactionNumber = 0\n\n  private lastTransactionNumber = 0\n\n  private lastSnapshot: EditorStateSnapshot<TEditor>\n\n  private editor: TEditor\n\n  private subscribers = new Set<() => void>()\n\n  constructor(initialEditor: TEditor) {\n    this.editor = initialEditor\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 }\n\n    this.getSnapshot = this.getSnapshot.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.watch = this.watch.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot(): EditorStateSnapshot<TEditor> {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot\n    }\n    this.lastTransactionNumber = this.transactionNumber\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }\n    return this.lastSnapshot\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): EditorStateSnapshot<null> {\n    return { editor: null, transactionNumber: 0 }\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback: () => void): () => void {\n    this.subscribers.add(callback)\n    return () => {\n      this.subscribers.delete(callback)\n    }\n  }\n\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor: Editor | null): undefined | (() => void) {\n    this.editor = nextEditor as TEditor\n\n    if (this.editor) {\n      /**\n       * This will force a re-render when the editor state changes.\n       * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n       * This could be more efficient, but it's a good trade-off for now.\n       */\n      const fn = () => {\n        this.transactionNumber += 1\n        this.subscribers.forEach(callback => callback())\n      }\n\n      const currentEditor = this.editor\n\n      currentEditor.on('transaction', fn)\n      return () => {\n        currentEditor.off('transaction', fn)\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor>,\n): TSelectorResult\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor> | UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null {\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor))\n\n  // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n  const selectedState = useSyncExternalStoreWithSelector(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector as UseEditorStateOptions<TSelectorResult, Editor | null>['selector'],\n    options.equalityFn ?? deepEqual,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor)\n  }, [options.editor, editorStateManager])\n\n  useDebugValue(selectedState)\n\n  return selectedState\n}\n","import type { ReactNode } from 'react'\nimport { createContext, createElement, useContext } from 'react'\n\nexport interface ReactNodeViewContextProps {\n  onDragStart?: (event: DragEvent) => void\n  nodeViewContentRef?: (element: HTMLElement | null) => void\n  /**\n   * This allows you to add children into the NodeViewContent component.\n   * This is useful when statically rendering the content of a node view.\n   */\n  nodeViewContentChildren?: ReactNode\n}\n\nexport const ReactNodeViewContext = createContext<ReactNodeViewContextProps>({\n  onDragStart: () => {\n    // no-op\n  },\n  nodeViewContentChildren: undefined,\n  nodeViewContentRef: () => {\n    // no-op\n  },\n})\n\nexport const ReactNodeViewContentProvider = ({ children, content }: { children: ReactNode; content: ReactNode }) => {\n  return createElement(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children)\n}\n\nexport const useReactNodeView = () => useContext(ReactNodeViewContext)\n","import type { ComponentProps } from 'react'\nimport React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport type NodeViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'div'> = {\n  as?: NoInfer<T>\n} & ComponentProps<T>\n\nexport function NodeViewContent<T extends keyof React.JSX.IntrinsicElements = 'div'>({\n  as: Tag = 'div' as T,\n  ...props\n}: NodeViewContentProps<T>) {\n  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView()\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={nodeViewContentRef}\n      data-node-view-content=\"\"\n      style={{\n        whiteSpace: 'pre-wrap',\n        ...props.style,\n      }}\n    >\n      {nodeViewContentChildren}\n    </Tag>\n  )\n}\n","import React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport interface NodeViewWrapperProps {\n  [key: string]: any\n  as?: React.ElementType\n}\n\nexport const NodeViewWrapper: React.FC<NodeViewWrapperProps> = React.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView()\n  const Tag = props.as || 'div'\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={ref}\n      data-node-view-wrapper=\"\"\n      onDragStart={onDragStart}\n      style={{\n        whiteSpace: 'normal',\n        ...props.style,\n      }}\n    />\n  )\n})\n","/* eslint-disable @typescript-eslint/no-shadow */\nimport type { MarkViewProps, MarkViewRenderer, MarkViewRendererOptions } from '@tiptap/core'\nimport { MarkView } from '@tiptap/core'\nimport React from 'react'\n\n// import { flushSync } from 'react-dom'\nimport { ReactRenderer } from './ReactRenderer.js'\n\nexport interface MarkViewContextProps {\n  markViewContentRef: (element: HTMLElement | null) => void\n}\nexport const ReactMarkViewContext = React.createContext<MarkViewContextProps>({\n  markViewContentRef: () => {\n    // do nothing\n  },\n})\n\nexport type MarkViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'span'> = {\n  as?: T\n} & Omit<React.ComponentProps<T>, 'as'>\n\nexport const MarkViewContent = <T extends keyof React.JSX.IntrinsicElements = 'span'>(\n  props: MarkViewContentProps<T>,\n) => {\n  const { as: Tag = 'span', ...rest } = props\n  const { markViewContentRef } = React.useContext(ReactMarkViewContext)\n\n  return (\n    // @ts-ignore\n    <Tag {...rest} ref={markViewContentRef} data-mark-view-content=\"\" />\n  )\n}\n\nexport interface ReactMarkViewRendererOptions extends MarkViewRendererOptions {\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  className?: string\n  attrs?: { [key: string]: string }\n}\n\nexport class ReactMarkView extends MarkView<React.ComponentType<MarkViewProps>, ReactMarkViewRendererOptions> {\n  renderer: ReactRenderer\n  contentDOMElement: HTMLElement | null\n  didMountContentDomElement = false\n\n  constructor(\n    component: React.ComponentType<MarkViewProps>,\n    props: MarkViewProps,\n    options?: Partial<ReactMarkViewRendererOptions>,\n  ) {\n    super(component, props, options)\n\n    const { as = 'span', attrs, className = '' } = options || {}\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) } satisfies MarkViewProps\n\n    this.contentDOMElement = document.createElement('span')\n\n    const markViewContentRef: MarkViewContextProps['markViewContentRef'] = el => {\n      if (el && this.contentDOMElement && el.firstChild !== this.contentDOMElement) {\n        el.appendChild(this.contentDOMElement)\n        this.didMountContentDomElement = true\n      }\n    }\n    const context: MarkViewContextProps = {\n      markViewContentRef,\n    }\n\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactMarkViewProvider: React.FunctionComponent<MarkViewProps> = React.memo(componentProps => {\n      return (\n        <ReactMarkViewContext.Provider value={context}>\n          {React.createElement(component, componentProps)}\n        </ReactMarkViewContext.Provider>\n      )\n    })\n\n    ReactMarkViewProvider.displayName = 'ReactNodeView'\n\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim(),\n    })\n\n    if (attrs) {\n      this.renderer.updateAttributes(attrs)\n    }\n  }\n\n  get dom() {\n    return this.renderer.element as HTMLElement\n  }\n\n  get contentDOM() {\n    if (!this.didMountContentDomElement) {\n      return null\n    }\n    return this.contentDOMElement as HTMLElement\n  }\n}\n\nexport function ReactMarkViewRenderer(\n  component: React.ComponentType<MarkViewProps>,\n  options: Partial<ReactMarkViewRendererOptions> = {},\n): MarkViewRenderer {\n  return props => new ReactMarkView(component, props, options)\n}\n","import type { Editor } from '@tiptap/core'\nimport type {\n  ComponentClass,\n  ForwardRefExoticComponent,\n  FunctionComponent,\n  PropsWithoutRef,\n  ReactNode,\n  RefAttributes,\n} from 'react'\nimport { version as reactVersion } from 'react'\nimport { flushSync } from 'react-dom'\n\nimport type { EditorWithContentComponent } from './Editor.js'\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component: any) {\n  return !!(typeof Component === 'function' && Component.prototype && Component.prototype.isReactComponent)\n}\n\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.forward_ref)' ||\n      Component.$$typeof.description === 'react.forward_ref')\n  )\n}\n\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */\nfunction isMemoComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.memo)' || Component.$$typeof.description === 'react.memo')\n  )\n}\n\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */\nfunction canReceiveRef(Component: any) {\n  // Check if it's a class component\n  if (isClassComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a forwardRef component\n  if (isForwardRefComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a memoized component\n  if (isMemoComponent(Component)) {\n    // For memoized components, check the wrapped component\n    const wrappedComponent = Component.type\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent)\n    }\n  }\n\n  return false\n}\n\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */\nfunction isReact19Plus(): boolean {\n  // React 19 is detected by checking React version if available\n  // In practice, we'll use a more conservative approach and assume React 18 behavior\n  // unless we can definitively detect React 19\n  try {\n    // @ts-ignore\n    if (reactVersion) {\n      const majorVersion = parseInt(reactVersion.split('.')[0], 10)\n      return majorVersion >= 19\n    }\n  } catch {\n    // Fallback to React 18 behavior if we can't determine version\n  }\n  return false\n}\n\nexport interface ReactRendererOptions {\n  /**\n   * The editor instance.\n   * @type {Editor}\n   */\n  editor: Editor\n\n  /**\n   * The props for the component.\n   * @type {Record<string, any>}\n   * @default {}\n   */\n  props?: Record<string, any>\n\n  /**\n   * The tag name of the element.\n   * @type {string}\n   * @default 'div'\n   */\n  as?: string\n\n  /**\n   * The class name of the element.\n   * @type {string}\n   * @default ''\n   * @example 'foo bar'\n   */\n  className?: string\n}\n\ntype ComponentType<R, P> =\n  | ComponentClass<P>\n  | FunctionComponent<P>\n  | ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<R>>\n\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n */\nexport class ReactRenderer<R = unknown, P extends Record<string, any> = object> {\n  id: string\n\n  editor: Editor\n\n  component: any\n\n  element: Element\n\n  props: P\n\n  reactElement: ReactNode\n\n  ref: R | null = null\n\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(\n    component: ComponentType<R, P>,\n    { editor, props = {}, as = 'div', className = '' }: ReactRendererOptions,\n  ) {\n    this.id = Math.floor(Math.random() * 0xffffffff).toString()\n    this.component = component\n    this.editor = editor as EditorWithContentComponent\n    this.props = props as P\n    this.element = document.createElement(as)\n    this.element.classList.add('react-renderer')\n\n    if (className) {\n      this.element.classList.add(...className.split(' '))\n    }\n\n    // If the editor is already initialized, we will need to\n    // synchronously render the component to ensure it renders\n    // together with Prosemirror's rendering.\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render()\n      })\n    } else {\n      queueMicrotask(() => {\n        this.render()\n      })\n    }\n  }\n\n  /**\n   * Render the React component.\n   */\n  render(): void {\n    const Component = this.component\n    const props = this.props\n    const editor = this.editor as EditorWithContentComponent\n\n    // Handle ref forwarding with React 18/19 compatibility\n    const isReact19 = isReact19Plus()\n    const componentCanReceiveRef = canReceiveRef(Component)\n\n    const elementProps = { ...props }\n\n    // Always remove ref if the component cannot receive it (unless React 19+)\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref\n    }\n\n    // Only assign our own ref if allowed\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      // @ts-ignore - Setting ref prop for compatible components\n      elementProps.ref = (ref: R) => {\n        this.ref = ref\n      }\n    }\n\n    this.reactElement = <Component {...elementProps} />\n\n    editor?.contentComponent?.setRenderer(this.id, this)\n  }\n\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props: Record<string, any> = {}): void {\n    this.props = {\n      ...this.props,\n      ...props,\n    }\n\n    this.render()\n  }\n\n  /**\n   * Destroy the React component.\n   */\n  destroy(): void {\n    const editor = this.editor as EditorWithContentComponent\n\n    editor?.contentComponent?.removeRenderer(this.id)\n  }\n\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes: Record<string, string>): void {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key])\n    })\n  }\n}\n","import type {\n  DecorationWithType,\n  Editor,\n  NodeViewRenderer,\n  NodeViewRendererOptions,\n  NodeViewRendererProps,\n} from '@tiptap/core'\nimport { getRenderedAttributes, NodeView } from '@tiptap/core'\nimport type { Node, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport type { Decoration, DecorationSource, NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\nimport type { ComponentType, NamedExoticComponent } from 'react'\nimport { createElement, createRef, memo } from 'react'\n\nimport type { EditorWithContentComponent } from './Editor.js'\nimport { ReactRenderer } from './ReactRenderer.js'\nimport type { ReactNodeViewProps } from './types.js'\nimport type { ReactNodeViewContextProps } from './useReactNodeView.js'\nimport { ReactNodeViewContext } from './useReactNodeView.js'\n\nexport interface ReactNodeViewRendererOptions extends NodeViewRendererOptions {\n  /**\n   * This function is called when the node view is updated.\n   * It allows you to compare the old node with the new node and decide if the component should update.\n   */\n  update:\n    | ((props: {\n        oldNode: ProseMirrorNode\n        oldDecorations: readonly Decoration[]\n        oldInnerDecorations: DecorationSource\n        newNode: ProseMirrorNode\n        newDecorations: readonly Decoration[]\n        innerDecorations: DecorationSource\n        updateProps: () => void\n      }) => boolean)\n    | null\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  /**\n   * The class name of the element wrapping the React component.\n   */\n  className?: string\n  /**\n   * Attributes that should be applied to the element wrapping the React component.\n   * If this is a function, it will be called each time the node view is updated.\n   * If this is an object, it will be applied once when the node view is mounted.\n   */\n  attrs?:\n    | Record<string, string>\n    | ((props: { node: ProseMirrorNode; HTMLAttributes: Record<string, any> }) => Record<string, string>)\n}\n\nexport class ReactNodeView<\n  T = HTMLElement,\n  Component extends ComponentType<ReactNodeViewProps<T>> = ComponentType<ReactNodeViewProps<T>>,\n  NodeEditor extends Editor = Editor,\n  Options extends ReactNodeViewRendererOptions = ReactNodeViewRendererOptions,\n> extends NodeView<Component, NodeEditor, Options> {\n  /**\n   * The renderer instance.\n   */\n  renderer!: ReactRenderer<unknown, ReactNodeViewProps<T>>\n\n  /**\n   * The element that holds the rich-text content of the node.\n   */\n  contentDOMElement!: HTMLElement | null\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    super(component, props, options)\n\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag)\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div')\n      }\n\n      this.contentDOMElement.dataset.nodeViewContentReact = ''\n      this.contentDOMElement.dataset.nodeViewWrapper = ''\n\n      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n      // With this fix it seems to work fine\n      // See: https://github.com/ueberdosis/tiptap/issues/1197\n      this.contentDOMElement.style.whiteSpace = 'inherit'\n\n      const contentTarget = this.dom.querySelector('[data-node-view-content]')\n\n      if (!contentTarget) {\n        return\n      }\n\n      contentTarget.appendChild(this.contentDOMElement)\n    }\n  }\n\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations as DecorationWithType[],\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: createRef<T>(),\n    } satisfies ReactNodeViewProps<T>\n\n    if (!(this.component as any).displayName) {\n      const capitalizeFirstChar = (string: string): string => {\n        return string.charAt(0).toUpperCase() + string.substring(1)\n      }\n\n      this.component.displayName = capitalizeFirstChar(this.extension.name)\n    }\n\n    const onDragStart = this.onDragStart.bind(this)\n    const nodeViewContentRef: ReactNodeViewContextProps['nodeViewContentRef'] = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        // remove the nodeViewWrapper attribute from the element\n        if (element.hasAttribute('data-node-view-wrapper')) {\n          element.removeAttribute('data-node-view-wrapper')\n        }\n        element.appendChild(this.contentDOMElement)\n      }\n    }\n    const context = { onDragStart, nodeViewContentRef }\n    const Component = this.component\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactNodeViewProvider: NamedExoticComponent<ReactNodeViewProps<T>> = memo(componentProps => {\n      return (\n        <ReactNodeViewContext.Provider value={context}>\n          {createElement(Component, componentProps)}\n        </ReactNodeViewContext.Provider>\n      )\n    })\n\n    ReactNodeViewProvider.displayName = 'ReactNodeView'\n\n    let as = this.node.isInline ? 'span' : 'div'\n\n    if (this.options.as) {\n      as = this.options.as\n    }\n\n    const { className = '' } = this.options\n\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)\n\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim(),\n    })\n\n    this.editor.on('selectionUpdate', this.handleSelectionUpdate)\n    this.updateElementAttributes()\n  }\n\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    if (\n      this.renderer.element.firstElementChild &&\n      !this.renderer.element.firstElementChild?.hasAttribute('data-node-view-wrapper')\n    ) {\n      throw Error('Please use the NodeViewWrapper component for your node view.')\n    }\n\n    return this.renderer.element as HTMLElement\n  }\n\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null\n    }\n\n    return this.contentDOMElement\n  }\n\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const { from, to } = this.editor.state.selection\n    const pos = this.getPos()\n\n    if (typeof pos !== 'number') {\n      return\n    }\n\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return\n      }\n\n      this.selectNode()\n    } else {\n      if (!this.renderer.props.selected) {\n        return\n      }\n\n      this.deselectNode()\n    }\n  }\n\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node: Node, decorations: readonly Decoration[], innerDecorations: DecorationSource): boolean {\n    const rerenderComponent = (props?: Record<string, any>) => {\n      this.renderer.updateProps(props)\n      if (typeof this.options.attrs === 'function') {\n        this.updateElementAttributes()\n      }\n    }\n\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node\n      const oldDecorations = this.decorations\n      const oldInnerDecorations = this.innerDecorations\n\n      this.node = node\n      this.decorations = decorations\n      this.innerDecorations = innerDecorations\n\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({ node, decorations, innerDecorations }),\n      })\n    }\n\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true\n    }\n\n    this.node = node\n    this.decorations = decorations\n    this.innerDecorations = innerDecorations\n\n    rerenderComponent({ node, decorations, innerDecorations })\n\n    return true\n  }\n\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true,\n    })\n    this.renderer.element.classList.add('ProseMirror-selectednode')\n  }\n\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false,\n    })\n    this.renderer.element.classList.remove('ProseMirror-selectednode')\n  }\n\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy()\n    this.editor.off('selectionUpdate', this.handleSelectionUpdate)\n    this.contentDOMElement = null\n  }\n\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj: Record<string, string> = {}\n\n      if (typeof this.options.attrs === 'function') {\n        const extensionAttributes = this.editor.extensionManager.attributes\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes)\n\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes })\n      } else {\n        attrsObj = this.options.attrs\n      }\n\n      this.renderer.updateAttributes(attrsObj)\n    }\n  }\n}\n\n/**\n * Create a React node view renderer.\n */\nexport function ReactNodeViewRenderer<T = HTMLElement>(\n  component: ComponentType<ReactNodeViewProps<T>>,\n  options?: Partial<ReactNodeViewRendererOptions>,\n): NodeViewRenderer {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe its `undefined` because <editor-content> isnt rendered yet\n    if (!(props.editor as EditorWithContentComponent).contentComponent) {\n      return {} as unknown as ProseMirrorNodeView\n    }\n\n    return new ReactNodeView<T>(component, props, options)\n  }\n}\n","export * from './Context.js'\nexport * from './EditorContent.js'\nexport * from './NodeViewContent.js'\nexport * from './NodeViewWrapper.js'\nexport * from './ReactMarkViewRenderer.js'\nexport * from './ReactNodeViewRenderer.js'\nexport * from './ReactRenderer.js'\nexport * from './types.js'\nexport * from './useEditor.js'\nexport * from './useEditorState.js'\nexport * from './useReactNodeView.js'\nexport * from '@tiptap/core'\n"],"mappings":";AAEA,SAAgBA,aAAA,EAAeC,UAAA,EAAYC,OAAA,QAAe;;;ACA1D,OAAOC,KAAA,IAASC,UAAA,QAAkB;AAClC,OAAOC,QAAA,MAAc;AACrB,SAASC,oBAAA,QAA4B;AA6B5B,SAAAC,QAAA,EAAAC,GAAA,EAmKHC,IAAA,QAnKG;AAxBT,IAAMC,SAAA,GAAY,SAAAA,CAAA,EAA8F;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAhEC,IAAA,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAAF,IAAA,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;EAAA;EAC9C,OAAQC,IAAA,IAAY;IAClBH,IAAA,CAAKI,OAAA,CAAQC,GAAA,IAAO;MAClB,IAAI,OAAOA,GAAA,KAAQ,YAAY;QAC7BA,GAAA,CAAIF,IAAI;MACV,WAAWE,GAAA,EAAK;QACd;QAAEA,GAAA,CAAmCC,OAAA,GAAUH,IAAA;MACjD;IACF,CAAC;EACH;AACF;AAKA,IAAMI,OAAA,GAA4DC,IAAA,IAA0B;EAAA,IAAzB;IAAEC;EAAiB,IAAAD,IAAA;EAEpF,MAAME,SAAA,GAAYlB,oBAAA,CAChBiB,gBAAA,CAAiBE,SAAA,EACjBF,gBAAA,CAAiBG,WAAA,EACjBH,gBAAA,CAAiBI,iBACnB;EAGA,OAAO,eAAAnB,GAAA,CAAAD,QAAA;IAAGqB,QAAA,EAAAC,MAAA,CAAOC,MAAA,CAAON,SAAS;EAAA,CAAE;AACrC;AAOA,SAASO,YAAA,EAAgC;EACvC,MAAMC,WAAA,GAAc,mBAAIC,GAAA,CAAgB;EACxC,IAAIT,SAAA,GAA+C,CAAC;EAEpD,OAAO;IAAA;AAAA;AAAA;IAILC,UAAUS,QAAA,EAAsB;MAC9BF,WAAA,CAAYG,GAAA,CAAID,QAAQ;MACxB,OAAO,MAAM;QACXF,WAAA,CAAYI,MAAA,CAAOF,QAAQ;MAC7B;IACF;IACAR,YAAA,EAAc;MACZ,OAAOF,SAAA;IACT;IACAG,kBAAA,EAAoB;MAClB,OAAOH,SAAA;IACT;IAAA;AAAA;AAAA;IAIAa,YAAYC,EAAA,EAAYC,QAAA,EAAyB;MAC/Cf,SAAA,GAAY;QACV,GAAGA,SAAA;QACH,CAACc,EAAE,GAAGjC,QAAA,CAASmC,YAAA,CAAaD,QAAA,CAASE,YAAA,EAAcF,QAAA,CAASG,OAAA,EAASJ,EAAE;MACzE;MAEAN,WAAA,CAAYd,OAAA,CAAQyB,UAAA,IAAcA,UAAA,CAAW,CAAC;IAChD;IAAA;AAAA;AAAA;IAIAC,eAAeN,EAAA,EAAY;MACzB,MAAMO,aAAA,GAAgB;QAAE,GAAGrB;MAAU;MAErC,OAAOqB,aAAA,CAAcP,EAAE;MACvBd,SAAA,GAAYqB,aAAA;MACZb,WAAA,CAAYd,OAAA,CAAQyB,UAAA,IAAcA,UAAA,CAAW,CAAC;IAChD;EACF;AACF;AAEO,IAAMG,iBAAA,GAAN,cAAgC3C,KAAA,CAAM4C,SAAA,CAG3C;EAOAC,YAAYC,KAAA,EAA2B;IA/FzC,IAAAC,EAAA;IAgGI,MAAMD,KAAK;IACX,KAAKE,gBAAA,GAAmBhD,KAAA,CAAMiD,SAAA,CAAU;IACxC,KAAKC,WAAA,GAAc;IAEnB,KAAKC,KAAA,GAAQ;MACXC,8BAAA,EAAgCC,OAAA,EAASN,EAAA,GAAAD,KAAA,CAAMQ,MAAA,KAAN,gBAAAP,EAAA,CAAoD3B,gBAAgB;IAC/G;EACF;EAEAmC,kBAAA,EAAoB;IAClB,KAAKC,IAAA,CAAK;EACZ;EAEAC,mBAAA,EAAqB;IACnB,KAAKD,IAAA,CAAK;EACZ;EAEAA,KAAA,EAAO;IACL,MAAMF,MAAA,GAAS,KAAKR,KAAA,CAAMQ,MAAA;IAE1B,IAAIA,MAAA,IAAU,CAACA,MAAA,CAAOI,WAAA,IAAeJ,MAAA,CAAOK,OAAA,CAAQpB,OAAA,EAAS;MAC3D,IAAIe,MAAA,CAAOlC,gBAAA,EAAkB;QAC3B;MACF;MAEA,MAAMmB,OAAA,GAAU,KAAKS,gBAAA,CAAiB/B,OAAA;MAEtCsB,OAAA,CAAQqB,MAAA,CAAO,GAAGN,MAAA,CAAOK,OAAA,CAAQpB,OAAA,CAAQsB,UAAU;MAEnDP,MAAA,CAAOQ,UAAA,CAAW;QAChBvB;MACF,CAAC;MAEDe,MAAA,CAAOlC,gBAAA,GAAmBQ,WAAA,CAAY;MAGtC,IAAI,CAAC,KAAKuB,KAAA,CAAMC,8BAAA,EAAgC;QAE9C,KAAKW,6BAAA,GAAgCT,MAAA,CAAOlC,gBAAA,CAAiBE,SAAA,CAAU,MAAM;UAC3E,KAAK0C,QAAA,CAASC,SAAA,IAAa;YACzB,IAAI,CAACA,SAAA,CAAUb,8BAAA,EAAgC;cAC7C,OAAO;gBACLA,8BAAA,EAAgC;cAClC;YACF;YACA,OAAOa,SAAA;UACT,CAAC;UAGD,IAAI,KAAKF,6BAAA,EAA+B;YACtC,KAAKA,6BAAA,CAA8B;UACrC;QACF,CAAC;MACH;MAEAT,MAAA,CAAOY,eAAA,CAAgB;MAEvB,KAAKhB,WAAA,GAAc;IACrB;EACF;EAEAiB,qBAAA,EAAuB;IA7JzB,IAAApB,EAAA;IA8JI,MAAMO,MAAA,GAAS,KAAKR,KAAA,CAAMQ,MAAA;IAE1B,IAAI,CAACA,MAAA,EAAQ;MACX;IACF;IAEA,KAAKJ,WAAA,GAAc;IAEnB,IAAI,CAACI,MAAA,CAAOI,WAAA,EAAa;MACvBJ,MAAA,CAAOc,IAAA,CAAKC,QAAA,CAAS;QACnBC,SAAA,EAAW,CAAC;MACd,CAAC;IACH;IAEA,IAAI,KAAKP,6BAAA,EAA+B;MACtC,KAAKA,6BAAA,CAA8B;IACrC;IAEAT,MAAA,CAAOlC,gBAAA,GAAmB;IAE1B,IAAI,GAAC2B,EAAA,GAAAO,MAAA,CAAOK,OAAA,CAAQpB,OAAA,KAAf,gBAAAQ,EAAA,CAAwBwB,UAAA,GAAY;MACvC;IACF;IAGA,MAAMC,UAAA,GAAaC,QAAA,CAASC,aAAA,CAAc,KAAK;IAE/CF,UAAA,CAAWZ,MAAA,CAAO,GAAGN,MAAA,CAAOK,OAAA,CAAQpB,OAAA,CAAQsB,UAAU;IAEtDP,MAAA,CAAOQ,UAAA,CAAW;MAChBvB,OAAA,EAASiC;IACX,CAAC;EACH;EAEAG,OAAA,EAAS;IACP,MAAM;MAAErB,MAAA;MAAQsB,QAAA;MAAU,GAAGC;IAAK,IAAI,KAAK/B,KAAA;IAE3C,OACE,eAAAxC,IAAA,CAAAF,QAAA;MACEqB,QAAA,kBAAApB,GAAA,CAAC;QAAIW,GAAA,EAAKT,SAAA,CAAUqE,QAAA,EAAU,KAAK5B,gBAAgB;QAAI,GAAG6B;MAAA,CAAM,IAE/DvB,MAAA,oBAAAA,MAAA,CAAQlC,gBAAA,KAAoB,eAAAf,GAAA,CAACa,OAAA;QAAQE,gBAAA,EAAkBkC,MAAA,CAAOlC;MAAA,CAAkB;IAAA,CACnF;EAEJ;AACF;AAGA,IAAM0D,oBAAA,GAAuB7E,UAAA,CAC3B,CAAC6C,KAAA,EAA6C9B,GAAA,KAAQ;EACpD,MAAM+D,GAAA,GAAM/E,KAAA,CAAMD,OAAA,CAAQ,MAAM;IAC9B,OAAOiF,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,MAAA,CAAO,IAAI,UAAU,EAAEC,QAAA,CAAS;EAEzD,GAAG,CAACrC,KAAA,CAAMQ,MAAM,CAAC;EAGjB,OAAOtD,KAAA,CAAM0E,aAAA,CAAc/B,iBAAA,EAAmB;IAC5CoC,GAAA;IACAH,QAAA,EAAU5D,GAAA;IACV,GAAG8B;EACL,CAAC;AACH,CACF;AAEO,IAAMsC,aAAA,GAAgBpF,KAAA,CAAMqF,IAAA,CAAKP,oBAAoB;;;AC9N5D,SAA6BQ,MAAA,QAAc;AAE3C,SAASC,aAAA,IAAAC,cAAA,EAAeC,SAAA,IAAAC,UAAA,EAAWC,MAAA,EAAQC,QAAA,IAAAC,SAAA,QAAgB;AAC3D,SAAS1F,oBAAA,IAAA2F,qBAAA,QAA4B;;;ACFrC,OAAOC,SAAA,MAAe;AACtB,SAASR,aAAA,EAAeE,SAAA,EAAWO,eAAA,EAAiBJ,QAAA,QAAgB;AACpE,SAASK,gCAAA,QAAwC;AAEjD,IAAMC,yBAAA,GAA4B,OAAOC,MAAA,KAAW,cAAcH,eAAA,GAAkBP,SAAA;AA2BpF,IAAMW,kBAAA,GAAN,MAAwE;EAWtEvD,YAAYwD,aAAA,EAAwB;IAVpC,KAAQC,iBAAA,GAAoB;IAE5B,KAAQC,qBAAA,GAAwB;IAMhC,KAAQ1E,WAAA,GAAc,mBAAIC,GAAA,CAAgB;IAGxC,KAAKwB,MAAA,GAAS+C,aAAA;IACd,KAAKG,YAAA,GAAe;MAAElD,MAAA,EAAQ+C,aAAA;MAAeC,iBAAA,EAAmB;IAAE;IAElE,KAAK/E,WAAA,GAAc,KAAKA,WAAA,CAAYkF,IAAA,CAAK,IAAI;IAC7C,KAAKjF,iBAAA,GAAoB,KAAKA,iBAAA,CAAkBiF,IAAA,CAAK,IAAI;IACzD,KAAKC,KAAA,GAAQ,KAAKA,KAAA,CAAMD,IAAA,CAAK,IAAI;IACjC,KAAKnF,SAAA,GAAY,KAAKA,SAAA,CAAUmF,IAAA,CAAK,IAAI;EAC3C;EAAA;AAAA;AAAA;EAKAlF,YAAA,EAA4C;IAC1C,IAAI,KAAK+E,iBAAA,KAAsB,KAAKC,qBAAA,EAAuB;MACzD,OAAO,KAAKC,YAAA;IACd;IACA,KAAKD,qBAAA,GAAwB,KAAKD,iBAAA;IAClC,KAAKE,YAAA,GAAe;MAAElD,MAAA,EAAQ,KAAKA,MAAA;MAAQgD,iBAAA,EAAmB,KAAKA;IAAkB;IACrF,OAAO,KAAKE,YAAA;EACd;EAAA;AAAA;AAAA;EAKAhF,kBAAA,EAA+C;IAC7C,OAAO;MAAE8B,MAAA,EAAQ;MAAMgD,iBAAA,EAAmB;IAAE;EAC9C;EAAA;AAAA;AAAA;EAKAhF,UAAUS,QAAA,EAAkC;IAC1C,KAAKF,WAAA,CAAYG,GAAA,CAAID,QAAQ;IAC7B,OAAO,MAAM;MACX,KAAKF,WAAA,CAAYI,MAAA,CAAOF,QAAQ;IAClC;EACF;EAAA;AAAA;AAAA;EAKA2E,MAAMC,UAAA,EAAqD;IACzD,KAAKrD,MAAA,GAASqD,UAAA;IAEd,IAAI,KAAKrD,MAAA,EAAQ;MAMf,MAAMsD,EAAA,GAAKA,CAAA,KAAM;QACf,KAAKN,iBAAA,IAAqB;QAC1B,KAAKzE,WAAA,CAAYd,OAAA,CAAQgB,QAAA,IAAYA,QAAA,CAAS,CAAC;MACjD;MAEA,MAAM8E,aAAA,GAAgB,KAAKvD,MAAA;MAE3BuD,aAAA,CAAcC,EAAA,CAAG,eAAeF,EAAE;MAClC,OAAO,MAAM;QACXC,aAAA,CAAcE,GAAA,CAAI,eAAeH,EAAE;MACrC;IACF;IAEA,OAAO;EACT;AACF;AA0CO,SAASI,eACdrD,OAAA,EACwB;EAzJ1B,IAAAZ,EAAA;EA0JE,MAAM,CAACkE,kBAAkB,IAAIrB,QAAA,CAAS,MAAM,IAAIQ,kBAAA,CAAmBzC,OAAA,CAAQL,MAAM,CAAC;EAGlF,MAAM4D,aAAA,GAAgBjB,gCAAA,CACpBgB,kBAAA,CAAmB3F,SAAA,EACnB2F,kBAAA,CAAmB1F,WAAA,EACnB0F,kBAAA,CAAmBzF,iBAAA,EACnBmC,OAAA,CAAQwD,QAAA,GACRpE,EAAA,GAAAY,OAAA,CAAQyD,UAAA,KAAR,OAAArE,EAAA,GAAsBgD,SACxB;EAEAG,yBAAA,CAA0B,MAAM;IAC9B,OAAOe,kBAAA,CAAmBP,KAAA,CAAM/C,OAAA,CAAQL,MAAM;EAChD,GAAG,CAACK,OAAA,CAAQL,MAAA,EAAQ2D,kBAAkB,CAAC;EAEvC1B,aAAA,CAAc2B,aAAa;EAE3B,OAAOA,aAAA;AACT;;;ADpKA,IAAMG,KAAA,GAAQC,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa;AACvC,IAAMC,KAAA,GAAQ,OAAOtB,MAAA,KAAW;AAChC,IAAMuB,MAAA,GAASD,KAAA,IAASpE,OAAA,CAAQ,OAAO8C,MAAA,KAAW,eAAgBA,MAAA,CAAewB,IAAI;AAwBrF,IAAMC,qBAAA,GAAN,MAAMC,sBAAA,CAAsB;EAqC1BhF,YAAYc,OAAA,EAA6C;IAjCzD;AAAA;AAAA;IAAA,KAAQL,MAAA,GAAwB;IAWhC;AAAA;AAAA;AAAA;IAAA,KAAQwE,aAAA,GAAgB,mBAAIhG,GAAA,CAAgB;IAU5C;AAAA;AAAA;IAAA,KAAQiG,kBAAA,GAAqB;IAK7B;AAAA;AAAA;IAAA,KAAQC,YAAA,GAAsC;IAK9C;AAAA;AAAA;IAAA,KAAOC,UAAA,GAAa;IAGlB,KAAKtE,OAAA,GAAUA,OAAA;IACf,KAAKmE,aAAA,GAAgB,mBAAIhG,GAAA,CAAgB;IACzC,KAAKoG,SAAA,CAAU,KAAKC,gBAAA,CAAiB,CAAC;IACtC,KAAKC,eAAA,CAAgB;IAErB,KAAKC,SAAA,GAAY,KAAKA,SAAA,CAAU5B,IAAA,CAAK,IAAI;IACzC,KAAKjF,iBAAA,GAAoB,KAAKA,iBAAA,CAAkBiF,IAAA,CAAK,IAAI;IACzD,KAAKnF,SAAA,GAAY,KAAKA,SAAA,CAAUmF,IAAA,CAAK,IAAI;IACzC,KAAK6B,qBAAA,GAAwB,KAAKA,qBAAA,CAAsB7B,IAAA,CAAK,IAAI;IACjE,KAAK2B,eAAA,GAAkB,KAAKA,eAAA,CAAgB3B,IAAA,CAAK,IAAI;IACrD,KAAK8B,QAAA,GAAW,KAAKA,QAAA,CAAS9B,IAAA,CAAK,IAAI;IACvC,KAAK+B,YAAA,GAAe,KAAKA,YAAA,CAAa/B,IAAA,CAAK,IAAI;EACjD;EAEQyB,UAAU5E,MAAA,EAAuB;IACvC,KAAKA,MAAA,GAASA,MAAA;IACd,KAAK2E,UAAA,GAAajD,IAAA,CAAKE,MAAA,CAAO,EAAEC,QAAA,CAAS,EAAE,EAAEsD,KAAA,CAAM,GAAG,CAAC;IAGvD,KAAKX,aAAA,CAAc/G,OAAA,CAAQ2H,EAAA,IAAMA,EAAA,CAAG,CAAC;EACvC;EAEQP,iBAAA,EAAmB;IACzB,IAAI,KAAKxE,OAAA,CAAQ1C,OAAA,CAAQ0H,iBAAA,KAAsB,QAAW;MACxD,IAAIlB,KAAA,IAASC,MAAA,EAAQ;QACnB,IAAIL,KAAA,EAAO;UAKT,MAAM,IAAIuB,KAAA,CACR,0HACF;QACF;QAGA,OAAO;MACT;MAGA,OAAO,KAAKJ,YAAA,CAAa;IAC3B;IAEA,IAAI,KAAK7E,OAAA,CAAQ1C,OAAA,CAAQ0H,iBAAA,IAAqBlB,KAAA,IAASJ,KAAA,EAAO;MAE5D,MAAM,IAAIuB,KAAA,CACR,kOACF;IACF;IAEA,IAAI,KAAKjF,OAAA,CAAQ1C,OAAA,CAAQ0H,iBAAA,EAAmB;MAC1C,OAAO,KAAKH,YAAA,CAAa;IAC3B;IAEA,OAAO;EACT;EAAA;AAAA;AAAA;EAKQA,aAAA,EAAuB;IAAA,IAAAK,KAAA;IAC7B,MAAMC,cAAA,GAAyC;MAC7C,GAAG,KAAKnF,OAAA,CAAQ1C,OAAA;MAAA;MAEhB8H,cAAA,EAAgB,SAAAA,CAAA,EAAU;QAxIhC,IAAAhG,EAAA,EAAAiG,EAAA;QAAA,SAAAC,KAAA,GAAAxI,SAAA,CAAAC,MAAA,EAwI0BwI,IAAA,OAAAtI,KAAA,CAAAqI,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;UAAAD,IAAA,CAAAC,KAAA,IAAA1I,SAAA,CAAA0I,KAAA;QAAA;QAAS,QAAAH,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQ8H,cAAA,KAArB,gBAAAC,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAsC,GAAGmG,IAAA;MAAA;MACtEG,MAAA,EAAQ,SAAAA,CAAA,EAAU;QAzIxB,IAAAtG,EAAA,EAAAiG,EAAA;QAAA,SAAAM,KAAA,GAAA7I,SAAA,CAAAC,MAAA,EAyIkBwI,IAAA,OAAAtI,KAAA,CAAA0I,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAAL,IAAA,CAAAK,KAAA,IAAA9I,SAAA,CAAA8I,KAAA;QAAA;QAAS,QAAAP,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQoI,MAAA,KAArB,gBAAAL,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAA8B,GAAGmG,IAAA;MAAA;MACtDM,QAAA,EAAU,SAAAA,CAAA,EAAU;QA1I1B,IAAAzG,EAAA,EAAAiG,EAAA;QAAA,SAAAS,KAAA,GAAAhJ,SAAA,CAAAC,MAAA,EA0IoBwI,IAAA,OAAAtI,KAAA,CAAA6I,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAAR,IAAA,CAAAQ,KAAA,IAAAjJ,SAAA,CAAAiJ,KAAA;QAAA;QAAS,QAAAV,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQuI,QAAA,KAArB,gBAAAR,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAgC,GAAGmG,IAAA;MAAA;MAC1DS,SAAA,EAAW,SAAAA,CAAA,EAAU;QA3I3B,IAAA5G,EAAA,EAAAiG,EAAA;QAAA,SAAAY,KAAA,GAAAnJ,SAAA,CAAAC,MAAA,EA2IqBwI,IAAA,OAAAtI,KAAA,CAAAgJ,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAAX,IAAA,CAAAW,KAAA,IAAApJ,SAAA,CAAAoJ,KAAA;QAAA;QAAS,QAAAb,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQ0I,SAAA,KAArB,gBAAAX,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAiC,GAAGmG,IAAA;MAAA;MAC5DY,OAAA,EAAS,SAAAA,CAAA,EAAU;QA5IzB,IAAA/G,EAAA,EAAAiG,EAAA;QAAA,SAAAe,KAAA,GAAAtJ,SAAA,CAAAC,MAAA,EA4ImBwI,IAAA,OAAAtI,KAAA,CAAAmJ,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAAd,IAAA,CAAAc,KAAA,IAAAvJ,SAAA,CAAAuJ,KAAA;QAAA;QAAS,QAAAhB,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQ6I,OAAA,KAArB,gBAAAd,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAA+B,GAAGmG,IAAA;MAAA;MACxDe,iBAAA,EAAmB,SAAAA,CAAA,EAAU;QA7InC,IAAAlH,EAAA,EAAAiG,EAAA;QAAA,SAAAkB,KAAA,GAAAzJ,SAAA,CAAAC,MAAA,EA6I6BwI,IAAA,OAAAtI,KAAA,CAAAsJ,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAAjB,IAAA,CAAAiB,KAAA,IAAA1J,SAAA,CAAA0J,KAAA;QAAA;QAAS,QAAAnB,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQgJ,iBAAA,KAArB,gBAAAjB,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAyC,GAAGmG,IAAA;MAAA;MAC5EkB,aAAA,EAAe,SAAAA,CAAA,EAAU;QA9I/B,IAAArH,EAAA,EAAAiG,EAAA;QAAA,SAAAqB,KAAA,GAAA5J,SAAA,CAAAC,MAAA,EA8IyBwI,IAAA,OAAAtI,KAAA,CAAAyJ,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAApB,IAAA,CAAAoB,KAAA,IAAA7J,SAAA,CAAA6J,KAAA;QAAA;QAAS,QAAAtB,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQmJ,aAAA,KAArB,gBAAApB,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAqC,GAAGmG,IAAA;MAAA;MACpEqB,QAAA,EAAU,SAAAA,CAAA,EAAU;QA/I1B,IAAAxH,EAAA,EAAAiG,EAAA;QAAA,SAAAwB,KAAA,GAAA/J,SAAA,CAAAC,MAAA,EA+IoBwI,IAAA,OAAAtI,KAAA,CAAA4J,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAAvB,IAAA,CAAAuB,KAAA,IAAAhK,SAAA,CAAAgK,KAAA;QAAA;QAAS,QAAAzB,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQsJ,QAAA,KAArB,gBAAAvB,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAgC,GAAGmG,IAAA;MAAA;MAC1DwB,cAAA,EAAgB,SAAAA,CAAA,EAAU;QAhJhC,IAAA3H,EAAA,EAAAiG,EAAA;QAAA,SAAA2B,KAAA,GAAAlK,SAAA,CAAAC,MAAA,EAgJ0BwI,IAAA,OAAAtI,KAAA,CAAA+J,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAA1B,IAAA,CAAA0B,KAAA,IAAAnK,SAAA,CAAAmK,KAAA;QAAA;QAAS,QAAA5B,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQyJ,cAAA,KAArB,gBAAA1B,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAsC,GAAGmG,IAAA;MAAA;MACtE2B,MAAA,EAAQ,SAAAA,CAAA,EAAU;QAjJxB,IAAA9H,EAAA,EAAAiG,EAAA;QAAA,SAAA8B,KAAA,GAAArK,SAAA,CAAAC,MAAA,EAiJkBwI,IAAA,OAAAtI,KAAA,CAAAkK,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAA7B,IAAA,CAAA6B,KAAA,IAAAtK,SAAA,CAAAsK,KAAA;QAAA;QAAS,QAAA/B,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQ4J,MAAA,KAArB,gBAAA7B,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAA8B,GAAGmG,IAAA;MAAA;MACtD8B,OAAA,EAAS,SAAAA,CAAA,EAAU;QAlJzB,IAAAjI,EAAA,EAAAiG,EAAA;QAAA,SAAAiC,MAAA,GAAAxK,SAAA,CAAAC,MAAA,EAkJmBwI,IAAA,OAAAtI,KAAA,CAAAqK,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;UAAAhC,IAAA,CAAAgC,MAAA,IAAAzK,SAAA,CAAAyK,MAAA;QAAA;QAAS,QAAAlC,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQ+J,OAAA,KAArB,gBAAAhC,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAA+B,GAAGmG,IAAA;MAAA;MACxDiC,QAAA,EAAU,SAAAA,CAAA,EAAU;QAnJ1B,IAAApI,EAAA,EAAAiG,EAAA;QAAA,SAAAoC,MAAA,GAAA3K,SAAA,CAAAC,MAAA,EAmJoBwI,IAAA,OAAAtI,KAAA,CAAAwK,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;UAAAnC,IAAA,CAAAmC,MAAA,IAAA5K,SAAA,CAAA4K,MAAA;QAAA;QAAS,QAAArC,EAAA,IAAAjG,EAAA,GAAA8F,KAAA,CAAKlF,OAAA,CAAQ1C,OAAA,EAAQkK,QAAA,KAArB,gBAAAnC,EAAA,CAAAI,IAAA,CAAArG,EAAA,EAAgC,GAAGmG,IAAA;MAAA;IAC5D;IACA,MAAM5F,MAAA,GAAS,IAAIgC,MAAA,CAAOwD,cAAc;IAIxC,OAAOxF,MAAA;EACT;EAAA;AAAA;AAAA;EAKA+E,UAAA,EAA2B;IACzB,OAAO,KAAK/E,MAAA;EACd;EAAA;AAAA;AAAA;EAKA9B,kBAAA,EAA0B;IACxB,OAAO;EACT;EAAA;AAAA;AAAA;EAKAF,UAAUgK,aAAA,EAA2B;IACnC,KAAKxD,aAAA,CAAc9F,GAAA,CAAIsJ,aAAa;IAEpC,OAAO,MAAM;MACX,KAAKxD,aAAA,CAAc7F,MAAA,CAAOqJ,aAAa;IACzC;EACF;EAEA,OAAOC,eAAeC,CAAA,EAAqBC,CAAA,EAAqB;IAC9D,OAAQ/J,MAAA,CAAOgK,IAAA,CAAKF,CAAC,EAAiCG,KAAA,CAAM5G,GAAA,IAAO;MACjE,IACE,CACE,YACA,kBACA,aACA,YACA,iBACA,WACA,UACA,qBACA,kBACA,UACA,UACF,CAAE6G,QAAA,CAAS7G,GAAG,GACd;QAEA,OAAO;MACT;MAGA,IAAIA,GAAA,KAAQ,gBAAgByG,CAAA,CAAEK,UAAA,IAAcJ,CAAA,CAAEI,UAAA,EAAY;QACxD,IAAIL,CAAA,CAAEK,UAAA,CAAWnL,MAAA,KAAW+K,CAAA,CAAEI,UAAA,CAAWnL,MAAA,EAAQ;UAC/C,OAAO;QACT;QACA,OAAO8K,CAAA,CAAEK,UAAA,CAAWF,KAAA,CAAM,CAACG,SAAA,EAAWC,KAAA,KAAU;UA/MxD,IAAAhJ,EAAA;UAgNU,IAAI+I,SAAA,OAAc/I,EAAA,GAAA0I,CAAA,CAAEI,UAAA,KAAF,gBAAA9I,EAAA,CAAegJ,KAAA,IAAQ;YACvC,OAAO;UACT;UACA,OAAO;QACT,CAAC;MACH;MACA,IAAIP,CAAA,CAAEzG,GAAG,MAAM0G,CAAA,CAAE1G,GAAG,GAAG;QAErB,OAAO;MACT;MACA,OAAO;IACT,CAAC;EACH;EAAA;AAAA;AAAA;AAAA;AAAA;EAOAwD,SAASyD,IAAA,EAAsB;IAE7B,OAAO,MAAM;MACX,KAAKjE,kBAAA,GAAqB;MAE1BkE,YAAA,CAAa,KAAKC,2BAA2B;MAE7C,IAAI,KAAK5I,MAAA,IAAU,CAAC,KAAKA,MAAA,CAAOI,WAAA,IAAesI,IAAA,CAAKtL,MAAA,KAAW,GAAG;QAEhE,IAAI,CAACmH,sBAAA,CAAsB0D,cAAA,CAAe,KAAK5H,OAAA,CAAQ1C,OAAA,EAAS,KAAKqC,MAAA,CAAOK,OAAO,GAAG;UAGpF,KAAKL,MAAA,CAAOQ,UAAA,CAAW;YACrB,GAAG,KAAKH,OAAA,CAAQ1C,OAAA;YAChBkL,QAAA,EAAU,KAAK7I,MAAA,CAAO8I;UACxB,CAAC;QACH;MACF,OAAO;QAML,KAAK9D,qBAAA,CAAsB0D,IAAI;MACjC;MAEA,OAAO,MAAM;QACX,KAAKjE,kBAAA,GAAqB;QAC1B,KAAKK,eAAA,CAAgB;MACvB;IACF;EACF;EAAA;AAAA;AAAA;EAKQE,sBAAsB0D,IAAA,EAAsB;IAClD,IAAI,KAAK1I,MAAA,IAAU,CAAC,KAAKA,MAAA,CAAOI,WAAA,EAAa;MAE3C,IAAI,KAAKsE,YAAA,KAAiB,MAAM;QAE9B,KAAKA,YAAA,GAAegE,IAAA;QACpB;MACF;MACA,MAAMK,YAAA,GACJ,KAAKrE,YAAA,CAAatH,MAAA,KAAWsL,IAAA,CAAKtL,MAAA,IAAU,KAAKsH,YAAA,CAAa2D,KAAA,CAAM,CAACW,GAAA,EAAKP,KAAA,KAAUO,GAAA,KAAQN,IAAA,CAAKD,KAAK,CAAC;MAEzG,IAAIM,YAAA,EAAc;QAEhB;MACF;IACF;IAEA,IAAI,KAAK/I,MAAA,IAAU,CAAC,KAAKA,MAAA,CAAOI,WAAA,EAAa;MAE3C,KAAKJ,MAAA,CAAOiJ,OAAA,CAAQ;IACtB;IAEA,KAAKrE,SAAA,CAAU,KAAKM,YAAA,CAAa,CAAC;IAGlC,KAAKR,YAAA,GAAegE,IAAA;EACtB;EAAA;AAAA;AAAA;AAAA;AAAA;EAOQ5D,gBAAA,EAAkB;IACxB,MAAMoE,iBAAA,GAAoB,KAAKvE,UAAA;IAC/B,MAAMpB,aAAA,GAAgB,KAAKvD,MAAA;IAG3B,KAAK4I,2BAAA,GAA8BO,UAAA,CAAW,MAAM;MAClD,IAAI,KAAK1E,kBAAA,IAAsB,KAAKE,UAAA,KAAeuE,iBAAA,EAAmB;QAEpE,IAAI3F,aAAA,EAAe;UAEjBA,aAAA,CAAc/C,UAAA,CAAW,KAAKH,OAAA,CAAQ1C,OAAO;QAC/C;QACA;MACF;MACA,IAAI4F,aAAA,IAAiB,CAACA,aAAA,CAAcnD,WAAA,EAAa;QAC/CmD,aAAA,CAAc0F,OAAA,CAAQ;QACtB,IAAI,KAAKtE,UAAA,KAAeuE,iBAAA,EAAmB;UACzC,KAAKtE,SAAA,CAAU,IAAI;QACrB;MACF;IAGF,GAAG,CAAC;EACN;AACF;AAuBO,SAASwE,UAAA,EAAoF;EAAA,IAA1E/I,OAAA,GAAAlD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAkM,SAAA,GAAAlM,SAAA,MAA4B,CAAC;EAAA,IAAGuL,IAAA,GAAAvL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAkM,SAAA,GAAAlM,SAAA,MAAuB,EAAC;EAChF,MAAMmM,iBAAA,GAAoBjH,MAAA,CAAOhC,OAAO;EAExCiJ,iBAAA,CAAkB3L,OAAA,GAAU0C,OAAA;EAE5B,MAAM,CAACkJ,eAAe,IAAIhH,SAAA,CAAS,MAAM,IAAI+B,qBAAA,CAAsBgF,iBAAiB,CAAC;EAErF,MAAMtJ,MAAA,GAASwC,qBAAA,CACb+G,eAAA,CAAgBvL,SAAA,EAChBuL,eAAA,CAAgBxE,SAAA,EAChBwE,eAAA,CAAgBrL,iBAClB;EAEAgE,cAAA,CAAclC,MAAM;EAIpBoC,UAAA,CAAUmH,eAAA,CAAgBtE,QAAA,CAASyD,IAAI,CAAC;EAIxChF,cAAA,CAAe;IACb1D,MAAA;IACA6D,QAAA,EAAU2F,KAAA,IAA2B;MAAA,IAA1B;QAAExG;MAAkB,IAAAwG,KAAA;MAC7B,IAAInJ,OAAA,CAAQoJ,2BAAA,KAAgC,SAASpJ,OAAA,CAAQoJ,2BAAA,KAAgC,QAAW;QAEtG,OAAO;MACT;MAGA,IAAIpJ,OAAA,CAAQgF,iBAAA,IAAqBrC,iBAAA,KAAsB,GAAG;QACxD,OAAO;MACT;MACA,OAAOA,iBAAA,GAAoB;IAC7B;EACF,CAAC;EAED,OAAOhD,MAAA;AACT;;;AF3UI,SAGoCjD,GAAA,IAAA2M,IAAA,EAHpC1M,IAAA,IAAA2M,KAAA;AAtCG,IAAMC,aAAA,GAAgBrN,aAAA,CAAkC;EAC7DyD,MAAA,EAAQ;AACV,CAAC;AAEM,IAAM6J,cAAA,GAAiBD,aAAA,CAAcE,QAAA;AAKrC,IAAMC,gBAAA,GAAmBA,CAAA,KAAMvN,UAAA,CAAWoN,aAAa;AAcvD,SAASI,eAAAC,KAAA,EAMQ;EAAA,IANO;IAC7B9L,QAAA;IACA+L,SAAA;IACAC,UAAA;IACAC,oBAAA,GAAuB,CAAC;IACxB,GAAGC;EACL,IAAAJ,KAAA;EACE,MAAMjK,MAAA,GAASoJ,SAAA,CAAUiB,aAAa;EACtC,MAAMC,YAAA,GAAe7N,OAAA,CAAQ,OAAO;IAAEuD;EAAO,IAAI,CAACA,MAAM,CAAC;EAEzD,IAAI,CAACA,MAAA,EAAQ;IACX,OAAO;EACT;EAEA,OACE,eAAA2J,KAAA,CAACC,aAAA,CAAcW,QAAA,EAAd;IAAuBC,KAAA,EAAOF,YAAA;IAC5BnM,QAAA,GAAAgM,UAAA,EACD,eAAAT,IAAA,CAACG,cAAA;MACE1L,QAAA,EAAAsM,KAAA;QAAA,IAAC;UAAEzK,MAAA,EAAQuD;QAAc,IAAAkH,KAAA;QAAA,OAAM,eAAAf,IAAA,CAAC5H,aAAA;UAAc9B,MAAA,EAAQuD,aAAA;UAAgB,GAAG6G;QAAA,CAAsB;MAAA;IAAA,CAClG,GACCjM,QAAA,EACA+L,SAAA;EAAA,CACH;AAEJ;;;AI1DA,SAAS3N,aAAA,IAAAmO,cAAA,EAAetJ,aAAA,EAAe5E,UAAA,IAAAmO,WAAA,QAAkB;AAYlD,IAAMC,oBAAA,GAAuBF,cAAA,CAAyC;EAC3EG,WAAA,EAAaA,CAAA,KAAM,CAEnB;EACAC,uBAAA,EAAyB;EACzBC,kBAAA,EAAoBA,CAAA,KAAM,CAE1B;AACF,CAAC;AAEM,IAAMC,4BAAA,GAA+BC,KAAA,IAAwE;EAAA,IAAvE;IAAE9M,QAAA;IAAU+M;EAAQ,IAAAD,KAAA;EAC/D,OAAO7J,aAAA,CAAcwJ,oBAAA,CAAqBL,QAAA,EAAU;IAAEC,KAAA,EAAO;MAAEM,uBAAA,EAAyBI;IAAQ;EAAE,GAAG/M,QAAQ;AAC/G;AAEO,IAAMgN,gBAAA,GAAmBA,CAAA,KAAMR,WAAA,CAAWC,oBAAoB;;;ACVjE,SAAA7N,GAAA,IAAAqO,IAAA;AARG,SAASC,gBAAAC,KAAA,EAGY;EAAA,IAHyD;IACnFC,EAAA,EAAIC,GAAA,GAAM;IACV,GAAGhM;EACL,IAAA8L,KAAA;EACE,MAAM;IAAEP,kBAAA;IAAoBD;EAAwB,IAAIK,gBAAA,CAAiB;EAEzE;IAAA;IAEE;IAAAC,IAAA,CAACI,GAAA;MACE,GAAGhM,KAAA;MACJ9B,GAAA,EAAKqN,kBAAA;MACL,0BAAuB;MACvBU,KAAA,EAAO;QACLC,UAAA,EAAY;QACZ,GAAGlM,KAAA,CAAMiM;MACX;MAECtN,QAAA,EAAA2M;IAAA,CACH;EAAA;AAEJ;;;AC7BA,OAAOa,MAAA,MAAW;AAed,SAAA5O,GAAA,IAAA6O,IAAA;AANG,IAAMC,eAAA,GAAkDF,MAAA,CAAMhP,UAAA,CAAW,CAAC6C,KAAA,EAAO9B,GAAA,KAAQ;EAC9F,MAAM;IAAEmN;EAAY,IAAIM,gBAAA,CAAiB;EACzC,MAAMK,GAAA,GAAMhM,KAAA,CAAM+L,EAAA,IAAM;EAExB;IAAA;IAEE;IAAAK,IAAA,CAACJ,GAAA;MACE,GAAGhM,KAAA;MACJ9B,GAAA;MACA,0BAAuB;MACvBmN,WAAA;MACAY,KAAA,EAAO;QACLC,UAAA,EAAY;QACZ,GAAGlM,KAAA,CAAMiM;MACX;IAAA,CACF;EAAA;AAEJ,CAAC;;;ACxBD,SAASK,QAAA,QAAgB;AACzB,OAAOC,MAAA,MAAW;;;ACMlB,SAASC,OAAA,IAAWC,YAAA,QAAoB;AACxC,SAASC,SAAA,QAAiB;AAkNF,SAAAnP,GAAA,IAAAoP,IAAA;AAzMxB,SAASC,iBAAiB9M,SAAA,EAAgB;EACxC,OAAO,CAAC,EAAE,OAAOA,SAAA,KAAc,cAAcA,SAAA,CAAU+M,SAAA,IAAa/M,SAAA,CAAU+M,SAAA,CAAUC,gBAAA;AAC1F;AAOA,SAASC,sBAAsBjN,SAAA,EAAgB;EAC7C,OAAO,CAAC,EACN,OAAOA,SAAA,KAAc,YACrBA,SAAA,CAAUkN,QAAA,KACTlN,SAAA,CAAUkN,QAAA,CAAS3K,QAAA,CAAS,MAAM,+BACjCvC,SAAA,CAAUkN,QAAA,CAASC,WAAA,KAAgB;AAEzC;AAOA,SAASC,gBAAgBpN,SAAA,EAAgB;EACvC,OAAO,CAAC,EACN,OAAOA,SAAA,KAAc,YACrBA,SAAA,CAAUkN,QAAA,KACTlN,SAAA,CAAUkN,QAAA,CAAS3K,QAAA,CAAS,MAAM,wBAAwBvC,SAAA,CAAUkN,QAAA,CAASC,WAAA,KAAgB;AAElG;AASA,SAASE,cAAcrN,SAAA,EAAgB;EAErC,IAAI8M,gBAAA,CAAiB9M,SAAS,GAAG;IAC/B,OAAO;EACT;EAGA,IAAIiN,qBAAA,CAAsBjN,SAAS,GAAG;IACpC,OAAO;EACT;EAGA,IAAIoN,eAAA,CAAgBpN,SAAS,GAAG;IAE9B,MAAMsN,gBAAA,GAAmBtN,SAAA,CAAUuN,IAAA;IACnC,IAAID,gBAAA,EAAkB;MACpB,OAAOR,gBAAA,CAAiBQ,gBAAgB,KAAKL,qBAAA,CAAsBK,gBAAgB;IACrF;EACF;EAEA,OAAO;AACT;AAMA,SAASE,cAAA,EAAyB;EAIhC,IAAI;IAEF,IAAIb,YAAA,EAAc;MAChB,MAAMc,YAAA,GAAeC,QAAA,CAASf,YAAA,CAAagB,KAAA,CAAM,GAAG,EAAE,CAAC,GAAG,EAAE;MAC5D,OAAOF,YAAA,IAAgB;IACzB;EACF,QAAQ,CAER;EACA,OAAO;AACT;AAgDO,IAAMG,aAAA,GAAN,MAAyE;EAAA;AAAA;AAAA;EAkB9E3N,YACE4N,SAAA,EAAAC,KAAA,EAEA;IAAA,IADA;MAAEpN,MAAA;MAAQR,KAAA,GAAQ,CAAC;MAAG+L,EAAA,GAAK;MAAO8B,SAAA,GAAY;IAAG,IAAAD,KAAA;IAPnD,KAAA1P,GAAA,GAAgB;IASd,KAAKmB,EAAA,GAAK6C,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,MAAA,CAAO,IAAI,UAAU,EAAEC,QAAA,CAAS;IAC1D,KAAKsL,SAAA,GAAYA,SAAA;IACjB,KAAKnN,MAAA,GAASA,MAAA;IACd,KAAKR,KAAA,GAAQA,KAAA;IACb,KAAKP,OAAA,GAAUkC,QAAA,CAASC,aAAA,CAAcmK,EAAE;IACxC,KAAKtM,OAAA,CAAQqO,SAAA,CAAU5O,GAAA,CAAI,gBAAgB;IAE3C,IAAI2O,SAAA,EAAW;MACb,KAAKpO,OAAA,CAAQqO,SAAA,CAAU5O,GAAA,CAAI,GAAG2O,SAAA,CAAUJ,KAAA,CAAM,GAAG,CAAC;IACpD;IAKA,IAAI,KAAKjN,MAAA,CAAOuN,aAAA,EAAe;MAC7BrB,SAAA,CAAU,MAAM;QACd,KAAK7K,MAAA,CAAO;MACd,CAAC;IACH,OAAO;MACLmM,cAAA,CAAe,MAAM;QACnB,KAAKnM,MAAA,CAAO;MACd,CAAC;IACH;EACF;EAAA;AAAA;AAAA;EAKAA,OAAA,EAAe;IApMjB,IAAA5B,EAAA;IAqMI,MAAMH,SAAA,GAAY,KAAK6N,SAAA;IACvB,MAAM3N,KAAA,GAAQ,KAAKA,KAAA;IACnB,MAAMQ,MAAA,GAAS,KAAKA,MAAA;IAGpB,MAAMyN,SAAA,GAAYX,aAAA,CAAc;IAChC,MAAMY,sBAAA,GAAyBf,aAAA,CAAcrN,SAAS;IAEtD,MAAMqO,YAAA,GAAe;MAAE,GAAGnO;IAAM;IAGhC,IAAImO,YAAA,CAAajQ,GAAA,IAAO,EAAE+P,SAAA,IAAaC,sBAAA,GAAyB;MAC9D,OAAOC,YAAA,CAAajQ,GAAA;IACtB;IAGA,IAAI,CAACiQ,YAAA,CAAajQ,GAAA,KAAQ+P,SAAA,IAAaC,sBAAA,GAAyB;MAE9DC,YAAA,CAAajQ,GAAA,GAAOA,GAAA,IAAW;QAC7B,KAAKA,GAAA,GAAMA,GAAA;MACb;IACF;IAEA,KAAKsB,YAAA,GAAe,eAAAmN,IAAA,CAAC7M,SAAA;MAAW,GAAGqO;IAAA,CAAc;IAEjD,CAAAlO,EAAA,GAAAO,MAAA,oBAAAA,MAAA,CAAQlC,gBAAA,KAAR,gBAAA2B,EAAA,CAA0Bb,WAAA,CAAY,KAAKC,EAAA,EAAI;EACjD;EAAA;AAAA;AAAA;EAKA+O,YAAA,EAAmD;IAAA,IAAvCpO,KAAA,GAAArC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAkM,SAAA,GAAAlM,SAAA,MAA6B,CAAC;IACxC,KAAKqC,KAAA,GAAQ;MACX,GAAG,KAAKA,KAAA;MACR,GAAGA;IACL;IAEA,KAAK6B,MAAA,CAAO;EACd;EAAA;AAAA;AAAA;EAKA4H,QAAA,EAAgB;IAhPlB,IAAAxJ,EAAA;IAiPI,MAAMO,MAAA,GAAS,KAAKA,MAAA;IAEpB,CAAAP,EAAA,GAAAO,MAAA,oBAAAA,MAAA,CAAQlC,gBAAA,KAAR,gBAAA2B,EAAA,CAA0BN,cAAA,CAAe,KAAKN,EAAA;EAChD;EAAA;AAAA;AAAA;EAKAgP,iBAAiBC,UAAA,EAA0C;IACzD1P,MAAA,CAAOgK,IAAA,CAAK0F,UAAU,EAAErQ,OAAA,CAAQgE,GAAA,IAAO;MACrC,KAAKxC,OAAA,CAAQ8O,YAAA,CAAatM,GAAA,EAAKqM,UAAA,CAAWrM,GAAG,CAAC;IAChD,CAAC;EACH;AACF;;;ADjOI,SAAA1E,GAAA,IAAAiR,IAAA;AAlBG,IAAMC,oBAAA,GAAuBlC,MAAA,CAAMxP,aAAA,CAAoC;EAC5E2R,kBAAA,EAAoBA,CAAA,KAAM,CAE1B;AACF,CAAC;AAMM,IAAMC,eAAA,GACX3O,KAAA,IACG;EACH,MAAM;IAAE+L,EAAA,EAAIC,GAAA,GAAM;IAAQ,GAAGjK;EAAK,IAAI/B,KAAA;EACtC,MAAM;IAAE0O;EAAmB,IAAInC,MAAA,CAAMvP,UAAA,CAAWyR,oBAAoB;EAEpE;IAAA;IAEE;IAAAD,IAAA,CAACxC,GAAA;MAAK,GAAGjK,IAAA;MAAM7D,GAAA,EAAKwQ,kBAAA;MAAoB,0BAAuB;IAAA,CAAG;EAAA;AAEtE;AAWO,IAAME,aAAA,GAAN,cAA4BtC,QAAA,CAA2E;EAK5GvM,YACE4N,SAAA,EACA3N,KAAA,EACAa,OAAA,EACA;IACA,MAAM8M,SAAA,EAAW3N,KAAA,EAAOa,OAAO;IAPjC,KAAAgO,yBAAA,GAA4B;IAS1B,MAAM;MAAE9C,EAAA,GAAK;MAAQ+C,KAAA;MAAOjB,SAAA,GAAY;IAAG,IAAIhN,OAAA,IAAW,CAAC;IAC3D,MAAMkO,cAAA,GAAiB;MAAE,GAAG/O,KAAA;MAAOqO,gBAAA,EAAkB,KAAKA,gBAAA,CAAiB1K,IAAA,CAAK,IAAI;IAAE;IAEtF,KAAKqL,iBAAA,GAAoBrN,QAAA,CAASC,aAAA,CAAc,MAAM;IAEtD,MAAM8M,kBAAA,GAAiEO,EAAA,IAAM;MAC3E,IAAIA,EAAA,IAAM,KAAKD,iBAAA,IAAqBC,EAAA,CAAGxN,UAAA,KAAe,KAAKuN,iBAAA,EAAmB;QAC5EC,EAAA,CAAGC,WAAA,CAAY,KAAKF,iBAAiB;QACrC,KAAKH,yBAAA,GAA4B;MACnC;IACF;IACA,MAAMM,OAAA,GAAgC;MACpCT;IACF;IAIA,MAAMU,qBAAA,GAAgE7C,MAAA,CAAMhK,IAAA,CAAK8M,eAAA,IAAkB;MACjG,OACE,eAAAb,IAAA,CAACC,oBAAA,CAAqB1D,QAAA,EAArB;QAA8BC,KAAA,EAAOmE,OAAA;QACnCxQ,QAAA,EAAA4N,MAAA,CAAM3K,aAAA,CAAc+L,SAAA,EAAW0B,eAAc;MAAA,CAChD;IAEJ,CAAC;IAEDD,qBAAA,CAAsBE,WAAA,GAAc;IAEpC,KAAKhQ,QAAA,GAAW,IAAIoO,aAAA,CAAc0B,qBAAA,EAAuB;MACvD5O,MAAA,EAAQR,KAAA,CAAMQ,MAAA;MACdR,KAAA,EAAO+O,cAAA;MACPhD,EAAA;MACA8B,SAAA,EAAW,QAAQ7N,KAAA,CAAMuP,IAAA,CAAKlC,IAAA,CAAKmC,IAAI,IAAI3B,SAAS,GAAG4B,IAAA,CAAK;IAC9D,CAAC;IAED,IAAIX,KAAA,EAAO;MACT,KAAKxP,QAAA,CAAS+O,gBAAA,CAAiBS,KAAK;IACtC;EACF;EAEA,IAAIY,IAAA,EAAM;IACR,OAAO,KAAKpQ,QAAA,CAASG,OAAA;EACvB;EAEA,IAAIkQ,WAAA,EAAa;IACf,IAAI,CAAC,KAAKd,yBAAA,EAA2B;MACnC,OAAO;IACT;IACA,OAAO,KAAKG,iBAAA;EACd;AACF;AAEO,SAASY,sBACdjC,SAAA,EAEkB;EAAA,IADlB9M,OAAA,GAAAlD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAkM,SAAA,GAAAlM,SAAA,MAAiD,CAAC;EAElD,OAAOqC,KAAA,IAAS,IAAI4O,aAAA,CAAcjB,SAAA,EAAW3N,KAAA,EAAOa,OAAO;AAC7D;;;AEvGA,SAASgP,qBAAA,EAAuBC,QAAA,QAAgB;AAIhD,SAASlO,aAAA,IAAAmO,cAAA,EAAe5P,SAAA,EAAWoC,IAAA,QAAY;AAkIvC,SAAAhF,GAAA,IAAAyS,IAAA;AAxFD,IAAMC,aAAA,GAAN,cAKGH,QAAA,CAAyC;EAWjD/P,YAAY4N,SAAA,EAAsB3N,KAAA,EAA8Ba,OAAA,EAA4B;IAC1F,MAAM8M,SAAA,EAAW3N,KAAA,EAAOa,OAAO;IAE/B,IAAI,CAAC,KAAK7C,IAAA,CAAKkS,MAAA,EAAQ;MACrB,IAAI,KAAKrP,OAAA,CAAQsP,oBAAA,EAAsB;QACrC,KAAKnB,iBAAA,GAAoBrN,QAAA,CAASC,aAAA,CAAc,KAAKf,OAAA,CAAQsP,oBAAoB;MACnF,OAAO;QACL,KAAKnB,iBAAA,GAAoBrN,QAAA,CAASC,aAAA,CAAc,KAAK5D,IAAA,CAAKoS,QAAA,GAAW,SAAS,KAAK;MACrF;MAEA,KAAKpB,iBAAA,CAAkBqB,OAAA,CAAQC,oBAAA,GAAuB;MACtD,KAAKtB,iBAAA,CAAkBqB,OAAA,CAAQE,eAAA,GAAkB;MAKjD,KAAKvB,iBAAA,CAAkB/C,KAAA,CAAMC,UAAA,GAAa;MAE1C,MAAMsE,aAAA,GAAgB,KAAKd,GAAA,CAAIe,aAAA,CAAc,0BAA0B;MAEvE,IAAI,CAACD,aAAA,EAAe;QAClB;MACF;MAEAA,aAAA,CAActB,WAAA,CAAY,KAAKF,iBAAiB;IAClD;EACF;EAAA;AAAA;AAAA;AAAA;EAMA0B,MAAA,EAAQ;IAAA,IAAAC,MAAA;IACN,MAAM3Q,KAAA,GAAQ;MACZQ,MAAA,EAAQ,KAAKA,MAAA;MACbxC,IAAA,EAAM,KAAKA,IAAA;MACX4S,WAAA,EAAa,KAAKA,WAAA;MAClBC,gBAAA,EAAkB,KAAKA,gBAAA;MACvBvP,IAAA,EAAM,KAAKA,IAAA;MACXwP,QAAA,EAAU;MACV9H,SAAA,EAAW,KAAKA,SAAA;MAChB+H,cAAA,EAAgB,KAAKA,cAAA;MACrBC,MAAA,EAAQA,CAAA,KAAM,KAAKA,MAAA,CAAO;MAC1B3C,gBAAA,EAAkB,SAAAA,CAAA;QAAA,IAACC,UAAA,GAAA3Q,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAkM,SAAA,GAAAlM,SAAA,MAAa,CAAC;QAAA,OAAMgT,MAAA,CAAKtC,gBAAA,CAAiBC,UAAU;MAAA;MACvE2C,UAAA,EAAYA,CAAA,KAAM,KAAKA,UAAA,CAAW;MAClC/S,GAAA,EAAKiC,SAAA,CAAa;IACpB;IAEA,IAAI,CAAE,KAAKwN,SAAA,CAAkB2B,WAAA,EAAa;MACxC,MAAM4B,mBAAA,GAAuBC,MAAA,IAA2B;QACtD,OAAOA,MAAA,CAAOC,MAAA,CAAO,CAAC,EAAEC,WAAA,CAAY,IAAIF,MAAA,CAAOG,SAAA,CAAU,CAAC;MAC5D;MAEA,KAAK3D,SAAA,CAAU2B,WAAA,GAAc4B,mBAAA,CAAoB,KAAKlI,SAAA,CAAUwG,IAAI;IACtE;IAEA,MAAMnE,WAAA,GAAc,KAAKA,WAAA,CAAY1H,IAAA,CAAK,IAAI;IAC9C,MAAM4H,kBAAA,GAAsE9L,OAAA,IAAW;MACrF,IAAIA,OAAA,IAAW,KAAKuP,iBAAA,IAAqBvP,OAAA,CAAQgC,UAAA,KAAe,KAAKuN,iBAAA,EAAmB;QAEtF,IAAIvP,OAAA,CAAQ8R,YAAA,CAAa,wBAAwB,GAAG;UAClD9R,OAAA,CAAQ+R,eAAA,CAAgB,wBAAwB;QAClD;QACA/R,OAAA,CAAQyP,WAAA,CAAY,KAAKF,iBAAiB;MAC5C;IACF;IACA,MAAMG,OAAA,GAAU;MAAE9D,WAAA;MAAaE;IAAmB;IAClD,MAAMzL,SAAA,GAAY,KAAK6N,SAAA;IAGvB,MAAM8D,qBAAA,GAAqElP,IAAA,CAAKwM,cAAA,IAAkB;MAChG,OACE,eAAAiB,IAAA,CAAC5E,oBAAA,CAAqBL,QAAA,EAArB;QAA8BC,KAAA,EAAOmE,OAAA;QACnCxQ,QAAA,EAAAoR,cAAA,CAAcjQ,SAAA,EAAWiP,cAAc;MAAA,CAC1C;IAEJ,CAAC;IAED0C,qBAAA,CAAsBnC,WAAA,GAAc;IAEpC,IAAIvD,EAAA,GAAK,KAAK/N,IAAA,CAAKoS,QAAA,GAAW,SAAS;IAEvC,IAAI,KAAKvP,OAAA,CAAQkL,EAAA,EAAI;MACnBA,EAAA,GAAK,KAAKlL,OAAA,CAAQkL,EAAA;IACpB;IAEA,MAAM;MAAE8B,SAAA,GAAY;IAAG,IAAI,KAAKhN,OAAA;IAEhC,KAAK6Q,qBAAA,GAAwB,KAAKA,qBAAA,CAAsB/N,IAAA,CAAK,IAAI;IAEjE,KAAKrE,QAAA,GAAW,IAAIoO,aAAA,CAAc+D,qBAAA,EAAuB;MACvDjR,MAAA,EAAQ,KAAKA,MAAA;MACbR,KAAA;MACA+L,EAAA;MACA8B,SAAA,EAAW,QAAQ,KAAK7P,IAAA,CAAKqP,IAAA,CAAKmC,IAAI,IAAI3B,SAAS,GAAG4B,IAAA,CAAK;IAC7D,CAAC;IAED,KAAKjP,MAAA,CAAOwD,EAAA,CAAG,mBAAmB,KAAK0N,qBAAqB;IAC5D,KAAKC,uBAAA,CAAwB;EAC/B;EAAA;AAAA;AAAA;AAAA;EAMA,IAAIjC,IAAA,EAAM;IA9KZ,IAAAzP,EAAA;IA+KI,IACE,KAAKX,QAAA,CAASG,OAAA,CAAQmS,iBAAA,IACtB,GAAC3R,EAAA,QAAKX,QAAA,CAASG,OAAA,CAAQmS,iBAAA,KAAtB,gBAAA3R,EAAA,CAAyCsR,YAAA,CAAa,4BACvD;MACA,MAAMzL,KAAA,CAAM,8DAA8D;IAC5E;IAEA,OAAO,KAAKxG,QAAA,CAASG,OAAA;EACvB;EAAA;AAAA;AAAA;AAAA;EAMA,IAAIkQ,WAAA,EAAa;IACf,IAAI,KAAK3R,IAAA,CAAKkS,MAAA,EAAQ;MACpB,OAAO;IACT;IAEA,OAAO,KAAKlB,iBAAA;EACd;EAAA;AAAA;AAAA;AAAA;EAMA0C,sBAAA,EAAwB;IACtB,MAAM;MAAEG,IAAA;MAAMC;IAAG,IAAI,KAAKtR,MAAA,CAAOH,KAAA,CAAM0R,SAAA;IACvC,MAAMC,GAAA,GAAM,KAAKhB,MAAA,CAAO;IAExB,IAAI,OAAOgB,GAAA,KAAQ,UAAU;MAC3B;IACF;IAEA,IAAIH,IAAA,IAAQG,GAAA,IAAOF,EAAA,IAAME,GAAA,GAAM,KAAKhU,IAAA,CAAKiU,QAAA,EAAU;MACjD,IAAI,KAAK3S,QAAA,CAASU,KAAA,CAAM8Q,QAAA,EAAU;QAChC;MACF;MAEA,KAAKoB,UAAA,CAAW;IAClB,OAAO;MACL,IAAI,CAAC,KAAK5S,QAAA,CAASU,KAAA,CAAM8Q,QAAA,EAAU;QACjC;MACF;MAEA,KAAKqB,YAAA,CAAa;IACpB;EACF;EAAA;AAAA;AAAA;AAAA;EAMAC,OAAOpU,IAAA,EAAY4S,WAAA,EAAoCC,gBAAA,EAA6C;IAClG,MAAMwB,iBAAA,GAAqBrS,KAAA,IAAgC;MACzD,KAAKV,QAAA,CAAS8O,WAAA,CAAYpO,KAAK;MAC/B,IAAI,OAAO,KAAKa,OAAA,CAAQiO,KAAA,KAAU,YAAY;QAC5C,KAAK6C,uBAAA,CAAwB;MAC/B;IACF;IAEA,IAAI3T,IAAA,CAAKqP,IAAA,KAAS,KAAKrP,IAAA,CAAKqP,IAAA,EAAM;MAChC,OAAO;IACT;IAEA,IAAI,OAAO,KAAKxM,OAAA,CAAQuR,MAAA,KAAW,YAAY;MAC7C,MAAME,OAAA,GAAU,KAAKtU,IAAA;MACrB,MAAMuU,cAAA,GAAiB,KAAK3B,WAAA;MAC5B,MAAM4B,mBAAA,GAAsB,KAAK3B,gBAAA;MAEjC,KAAK7S,IAAA,GAAOA,IAAA;MACZ,KAAK4S,WAAA,GAAcA,WAAA;MACnB,KAAKC,gBAAA,GAAmBA,gBAAA;MAExB,OAAO,KAAKhQ,OAAA,CAAQuR,MAAA,CAAO;QACzBE,OAAA;QACAC,cAAA;QACAE,OAAA,EAASzU,IAAA;QACT0U,cAAA,EAAgB9B,WAAA;QAChB4B,mBAAA;QACA3B,gBAAA;QACAzC,WAAA,EAAaA,CAAA,KAAMiE,iBAAA,CAAkB;UAAErU,IAAA;UAAM4S,WAAA;UAAaC;QAAiB,CAAC;MAC9E,CAAC;IACH;IAEA,IAAI7S,IAAA,KAAS,KAAKA,IAAA,IAAQ,KAAK4S,WAAA,KAAgBA,WAAA,IAAe,KAAKC,gBAAA,KAAqBA,gBAAA,EAAkB;MACxG,OAAO;IACT;IAEA,KAAK7S,IAAA,GAAOA,IAAA;IACZ,KAAK4S,WAAA,GAAcA,WAAA;IACnB,KAAKC,gBAAA,GAAmBA,gBAAA;IAExBwB,iBAAA,CAAkB;MAAErU,IAAA;MAAM4S,WAAA;MAAaC;IAAiB,CAAC;IAEzD,OAAO;EACT;EAAA;AAAA;AAAA;AAAA;EAMAqB,WAAA,EAAa;IACX,KAAK5S,QAAA,CAAS8O,WAAA,CAAY;MACxB0C,QAAA,EAAU;IACZ,CAAC;IACD,KAAKxR,QAAA,CAASG,OAAA,CAAQqO,SAAA,CAAU5O,GAAA,CAAI,0BAA0B;EAChE;EAAA;AAAA;AAAA;AAAA;EAMAiT,aAAA,EAAe;IACb,KAAK7S,QAAA,CAAS8O,WAAA,CAAY;MACxB0C,QAAA,EAAU;IACZ,CAAC;IACD,KAAKxR,QAAA,CAASG,OAAA,CAAQqO,SAAA,CAAU6E,MAAA,CAAO,0BAA0B;EACnE;EAAA;AAAA;AAAA;EAKAlJ,QAAA,EAAU;IACR,KAAKnK,QAAA,CAASmK,OAAA,CAAQ;IACtB,KAAKjJ,MAAA,CAAOyD,GAAA,CAAI,mBAAmB,KAAKyN,qBAAqB;IAC7D,KAAK1C,iBAAA,GAAoB;EAC3B;EAAA;AAAA;AAAA;AAAA;EAMA2C,wBAAA,EAA0B;IACxB,IAAI,KAAK9Q,OAAA,CAAQiO,KAAA,EAAO;MACtB,IAAI8D,QAAA,GAAmC,CAAC;MAExC,IAAI,OAAO,KAAK/R,OAAA,CAAQiO,KAAA,KAAU,YAAY;QAC5C,MAAM+D,mBAAA,GAAsB,KAAKrS,MAAA,CAAOsS,gBAAA,CAAiBxE,UAAA;QACzD,MAAMyC,cAAA,GAAiBlB,qBAAA,CAAsB,KAAK7R,IAAA,EAAM6U,mBAAmB;QAE3ED,QAAA,GAAW,KAAK/R,OAAA,CAAQiO,KAAA,CAAM;UAAE9Q,IAAA,EAAM,KAAKA,IAAA;UAAM+S;QAAe,CAAC;MACnE,OAAO;QACL6B,QAAA,GAAW,KAAK/R,OAAA,CAAQiO,KAAA;MAC1B;MAEA,KAAKxP,QAAA,CAAS+O,gBAAA,CAAiBuE,QAAQ;IACzC;EACF;AACF;AAKO,SAASG,sBACdpF,SAAA,EACA9M,OAAA,EACkB;EAClB,OAAOb,KAAA,IAAS;IAId,IAAI,CAAEA,KAAA,CAAMQ,MAAA,CAAsClC,gBAAA,EAAkB;MAClE,OAAO,CAAC;IACV;IAEA,OAAO,IAAI2R,aAAA,CAAiBtC,SAAA,EAAW3N,KAAA,EAAOa,OAAO;EACvD;AACF;;;AC5UA,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}